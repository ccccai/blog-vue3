{"id":21,"title":"微信小程序-创建基于stomp协议的WebSocket连接","subTitle":"","link":null,"description":"","content":"### 1.在工具类文件夹utils下引入stomp.js或者stomp.min.js文件\n> stomp.js搜一下就能找到，实在找不到有时间我可以把文件贴出来\n\n### 2、在utils目录下定义WebSocket工具类文件socket.js\n```javascript\nconst appData = getApp()\nconst webScoket = {\n  // 创建基于STOMP协议的WebSocket\n  client: function () {\n    const Stomp = require('./stomp.min.js').Stomp\n    // setInterval是用来发心跳包的，而小程序没有window对象，所以要重新定义\n    Stomp.setInterval = (interval, f) => {\n      return setInterval(f, interval)\n    }\n    Stomp.clearInterval = (interval, f) => {\n      return clearInterval(id)\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        const stompClient = Stomp.over(appData.globalData.ws)\n        resolve(stompClient)\n      } catch (e) {\n        reject(e)\n      }\n    })\n  },\n  // 初始化\n  init: function (url = '') {\n    // 增加全局webscoket配置\n    appData.globalData.isConnected = false\n    appData.globalData.isReConnect = true // 允许断线重连\n    appData.globalData.reConnectLimit = -1 // 断线重连次数，-1不限次数\n    appData.globalData.msgQueue = []\n    appData.globalData.wsUrl = url || 'wss:wss地址'\n    appData.globalData.ws = {\n      send: this.sendMsg,\n      close: this.disConnect,\n      onopen: null,\n      onclose: null,\n      onmessage: null\n    }\n    const that = this\n    return new Promise((resolve, reject) => {\n      //连接\n      this.connect({\n        success(msg) {\n          that.onOpen() // 打开连接\n          that.onMsg() //接收数据\n          that.onError() //监听连接错误\n          that.onClose() // 监听连接是否关闭\n          resolve(msg)\n        },\n        fail(err) {\n          reject(err)\n        }\n      })\n    })\n  },\n  // 创建一个WebSocket连接，params:{url:'String',success:'successCallback',fail:'failCallback'}\n  connect: function (params = {}) {\n    console.log('connect')\n    wx.connectSocket({\n      url: appData.globalData.wsUrl,\n      success: (msg) => {\n        if (params.hasOwnProperty('success')) {\n          params.success(msg)\n        }\n      },\n      fail: (err) => {\n        if (params.hasOwnProperty('fail')) {\n          params.fail(err)\n        }\n      }\n    })\n  },\n  // 监听WebSocket连接打开事件\n  onOpen: function () {\n    console.log('onopen')\n    wx.onSocketOpen((res) => {\n      console.log('WebSocket连接已打开')\n      appData.globalData.isConnected = true\n      // 执行队列里未发送的任务\n      appData.globalData.msgQueue.forEach(item => {\n        this.sendMsg(item)\n      })\n      appData.globalData.msgQueue = []\n      appData.globalData.ws.onopen && appData.globalData.ws.onopen()\n    })\n  },\n  // 发送消息\n  sendMsg: function (msg) {\n    console.log('sendmsg')\n    // 如果WebSocket已连接则发送消息\n    if (appData.globalData.isConnected) {\n      wx.sendSocketMessage({\n        data: msg\n      })\n    } else {\n      // WebSocket没有连接将消息放入队列中\n      appData.globalData.msgQueue.push(msg)\n    }\n  },\n  // 监听WebSocket接受到服务器的消息事件\n  onMsg: function () {\n    console.log('onmsg')\n    wx.onSocketMessage((res) => {\n      console.log('WebSocket收到消息事件：', res)\n      appData.globalData.ws.onmessage && appData.globalData.ws.onmessage(res)\n    })\n  },\n  // 监听WebSocket连接错误事件\n  onError: (res) => {\n    console.log('onerror')\n    wx.onSocketError((res) => {\n      console.log(\"WebSocket错误事件：\", res)\n    })\n  },\n  // 关闭WebSocket连接\n  disConnect: function () {\n    console.log('disconnect')\n    wx.closeSocket()\n  },\n  // 监听WebSocket连接关闭事件\n  onClose: function () {\n    console.log('onclose')\n    wx.onSocketClose((res) => {\n      console.log('WebSocket连接关闭：', res)\n      appData.globalData.ws.onclose && appData.globalData.ws.onclose(res)\n      appData.globalData.isConnected = false\n      // 断线重连\n      if (appData.globalData.isReConnect) {\n        // 调整重连的次数\n        if (!appData.globalData.hasOwnProperty('reConnectLimit') || appData.globalData.reConnectLimit === 0) {\n          appData.globalData.isReConnect = false\n        } else {\n          if (appData.globalData.reConnectLimit > 0) {\n            appData.globalData.reConnectLimit--\n          }\n          console.log('剩余重连次数：', appData.globalData.reConnectLimit)\n          this.connect({\n            fail(err) {\n              console.log('重新连接失败：', err)\n            }\n          })\n        }\n      }\n    })\n  }\n}\n\nexport default webScoket\n```\n\n### 3、使用\n#### 3-1、在要使用到的页面引入工具类文件\n```\nimport webScoket from '../../utils/socket'\nlet stompClient = ''\n```\n\n#### 3-2、在onShow函数中初始化\n```javascript\nonShow() {\n    const that = this\n    Promise.all([webScoket.init(), webScoket.client()]).then(result => {\n      stompClient = result[1]\n      stompClient.connect({}, () => {\n          stompClient.subscribe('订阅地址', response => {\n            console.log('收到订阅消息')\n            if (response.body) {\n              const res = JSON.parse(response.body)\n    \n              // 业务逻辑\n            }\n          })\n        })\n    })\n}\n\nonHide() {\n    app.globalData.isReConnect = false\n    stompClient.disconnect()\n}\n\nonUnload() {\n    app.globalData.isReConnect = false\n    stompClient.disconnect()\n}\n```\n\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/1/16f61272efd8752a~tplv-t2oaga2asx-image.image)\n控制台打印成功连接的信息，到这里就完成了","tagIds":"11","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":77,"type":1,"groupTimestamp":"1577826706992","cover":"https://static.turbosquid.com/Preview/2014/07/11__13_44_26/5.jpg3269969f-c6d9-4ffe-9a64-37330f9ceb79DefaultHQ.jpg","categoryId":1,"created_at":"2023-11-22T21:13:16.000Z","updated_at":"2023-11-22T21:41:16.000Z","tagList":[{"id":11,"name":"JavaScript"}],"createDate":"2020-01-01"}