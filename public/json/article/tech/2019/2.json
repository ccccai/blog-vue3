{
    "id": 2,
    "title": "JavaScript中数组的常用方法",
    "subTitle": "包含es6中的数组方法",
    "link": null,
    "description": "记录在开发中经常会遇到、用到的处理数组的方法",
    "content": "### 1. concat()，不改变原数组\n> **arr1.concat(arr2) 连接两个或多个数组，返回一个新的数组**\n\n```\nconst arr1 = [1, 2, 3]\nconst arr2 = [4, 5]\nconst newArr = arr1.concat(arr2)\nconsole.log(newArr) // [1, 2, 3, 4, 5]\n```\n\n### 2. join()，不改变原数组\n> **join(str) 数组转字符串，方法只接受一个参数，默认为逗号分隔符**\n\n```\nconat arr = [1, 2, 3]\nconsole.log(arr) // [1, 2, 3]\nconsole.log(arr.join()) // 1,2,3\nconsole.log(arr.join(:)) // 1:2:3\n```\n- tips: join() 实现重复字符串\n\n```\nconst str = new Array(4).join('啦')\nconsole.log(str) // 啦啦啦\n```\n### 3. push() & unshift() 添加元素操作，改变了原数组\n> **push() 向数组的末尾添加一个或多个元素，并返回新的长度**\n\n```\nconst arr = [1, 2]\nconsole.log(arr.push(3)) // 3\nconsole.log(arr) // [1, 2, 3]\n```\n> **unshift() 向数组的开头添加一个或多个元素，并返回新的长度**\n\n```\nconst arr = [1, 2]\nconsole.log(arr.unshift(3)) // 3\nconsole.log(arr) // [3, 1, 2]\n```\n\n### 4. shift() & pop() 删除元素操作，改变了原数组\n> **shift() 删除并返回数组第一个元素**\n\n```\nconst arr = [1, 2, 3]\nconst deleteItem = arr.shift()\nconsole.log(arr) // [2, 3]\nconsole.log(deleteItem) // 1\n```\n\n> **pop() 删除并返回数组最后一个元素**\n\n```\nconst arr = [1, 2, 3]\nconst deleteItem = arr.pop()\nconsole.log(arr) // [1, 2]\nconsole.log(deleteItem) // 3\n```\n\n### 5. sort() 数组排序，改变原数组\n> **sort() 对数组的元素进行排序**\n\n```\nconst arr = [2, 4, 3, 1]\nconsole.log(arr.sort()) // [1, 2, 3, 4]\nconsole.log(arr) // [1, 2, 3, 4]\n```\n- tips: sort() 不按照数组元素数值的大小对数字进行排序，是按照字符编码的顺序进行排序，那怎么样根据元素数值大小进行排序呢？\n```\nconst arr = [2, 4, 3, 1]\nconst arr1 = [...arr].sort((a, b) => a - b)\nconst arr2 = [...arr].sort((a, b) => b - a)\nconsole.log(arr1) // [1, 2, 3, 4]\nconsole.log(arr2) // [4, 3, 2, 1]\n```\n### 6. reverse() 反转数组，改变原数组\n> **reverse() 颠倒数组中元素的顺序**\n\n```\nconst arr = [2, 4, 3, 1]\nconsole.log(arr.reverse()) // [1, 3, 4, 2]\nconsole.log(arr) // [1, 3, 4, 2]\n```\n### 7. slice() 截取数组，不改变原数组\n> **arr.slice(start, end) 从start处开始选取（不包括该元素），从end处结束选取，如果为空的话，那么选取从start到数组结束的所有元素。负数代表方向，从数组尾部开始计算位置**\n\n```\nconst arr = [1, 2, 3, 4, 6]\nconsole.log(arr.slice(1)) // [2, 3, 4, 6]\nconsole.log(arr.slice(1, -2)) // [2, 3]\nconsole.log(arr.slice(-3, 1)) // [2]\nconsole.log(arr) // [1, 2, 3, 4, 6]\n```\n### 8. splice() 更新数组，改变原数组\n> **arr.splice(index, howmany, item1, ..., itemX) 向/从数组中添加/删除项目，然后返回被删除的项目，返回含有被删除的元素的数组，若没有删除元素则返回一个空数组。**\n- [index] 必传项，整数，规定添加/删除项目的位置，负数表示从数组结尾处规定位置\n- [howmany] 必传项，要删除的项目数量。如果设置为 0，则不会删除项目\n- [item1, ..., itemX] 可选。向数组添加的新项目。\n\n```\nconst arr = [1, 2, 3]\nconst arr1 = arr.splice(2, 1)\nconsole.log(arr1) // [3]\nconsole.log(arr) // [1, 2]\n\nconst arr2 = arr.splice(1, 0, 'ss')\nconsole.log(arr2) // ['ss']\nconsole.log(arr) // [1,'ss', 2]\n```\n### 9. indexOf() & lastIndexOf()  索引方法，不改变原数组\n> **两个方法都是返回要查找的项所在数组中首次出现的位置，没找到的话就返回-1。**\n\n> **arr.indexOf(item, start) 从数组的开头开始向后寻找。**\n\n> **arr.lastIndexOf(item, start) 从数组的末尾开始向前查找。**\n- [item] 必须项，查找的元素\n- [start] 可选，在数组中开始检索的位置，默认0\n\n```\nconst arr = [2, 4, 1, 9, 1, 2]\nconsole.log(arr.indexOf(2)) // 0\nconsole.log(arr.lastIndexOf(1)) // 1\nconsole.log(arr.indexOf(3)) // -1\n```\n### 10. find() & findIndex() 根据函数内的判断返回找到的数组内的第一个元素。不改变原数组。 ==（es6新增方法）==\n- 对于空数组不执行\n- [currentValue] 必须项，当前元素\n- [index] 可选。当前元素的索引值\n- [arr] 可选。当前元素所属的数组对象\n> **arr.find((currentValue, index, arr) => {}) 返回通过测试函数内判断的数组的第一个元素的值。当数组中的元素在测试函数中返回true时，返回符合条件的元素，之后不再调用测试函数判断剩下的元素，如果每个元素都执行了测试函数，没有符合的元素，则返回undefined。**\n\n```\nconst arr = [1, 2, 3, 4]\nconst findItem = arr.find((item, index) => {\n    return item > 2\n})\nconst findItem1 = arr.find((item, index) => {\n    return item > 5\n})\nconsole.log(findItem) // 3\nconsole.log(findItem1) // undefined\n```\n\n> **findIndex((currentValue, index, arr) => {}) 用法和find()一样，不同的是不是返回数组内元素，而是返回符合测试函数判断的元素索引值，如果没有符合条件的元素返回 -1。**\n\n```\nconst arr = [1, 2, 3, 4]\nconst findItemIndex = arr.findIndex((item, index) => {\n    return item > 2\n})\nconst findItemIndex1 = arr.findIndex((item, index) => {\n    return item > 5\n})\nconsole.log(findItemIndex) // 2\nconsole.log(findItemIndex1) // -1\n```\n### 11. forEach()、map()、filter()、some()、every() 迭代方法，不改变原数组。\n\n> **arr.forEach((currentValue , index , arr) => {},  thisValue) 对数组进行遍历循环，这个方法没有返回值。**\n- 对于空数组不执行\n- [currentValue] 必须项，当前元素\n- [index] 可选。当前元素的索引值\n- [arr] 可选。当前元素所属的数组对象\n- [thisValue] 可选。传递给函数的值一般用 \"this\" 值。如果这个参数为空， \"undefined\" 会传递给 \"this\" 值。\n\n```\nconst arr = [1,4,7,10];\narr.forEach((currentValue, index, arr) => {\n\tconsole.log(index + \"--\" + currentValue + \"--\" + (arr === Arr))\t\n})\n// 输出：\n// 0--1--true\n// 1--4--true\n// 2--7--true\n// 3--10--true\t\n```\n> **arr.map((currentValue , index , arr) => {},  thisValue) 指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。（不会改变数组长度，和原数组长度保持一致）**\n\n```\nconst arr = [1, 2, 3]\nconst arr1 = arr.map((currentValue) => {\n\treturn currentValue + 1\n})\nconsole.log(arr) // [1, 2, 3]\nconsole.log(arr1) // [2, 3, 4]\n```\n\n> **arr.filter((currentValue , index , arr) => {},  thisValue) “过滤”功能，方法\n创建一个新数组，其包含通过所提供函数实现的测试的所有元素。（可以改变数组长度，不必和原数组长度保持一致）**\n\n```\nconst arr = [1, 2, 3]\nconst arr1 = arr.filter((currentValue) => {\n\treturn currentValue > 1\n})\nconst arr2 = arr.filter((currentValue) => {\n\treturn currentValue > '1'\n})\nconsole.log(arr) // [1, 2, 3]\nconsole.log(arr1) // [2, 3]\nconsole.log(arr2) // [2, 3]\n```\n- arr1和arr2结果一致，可以看出函数支持弱等于，不是必须全等于\n> **arr.some((currentValue , index , arr) => {},  thisValue) 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true，不再往下执行。**\n\n```\nconst arr = [1, 2, 3]\nconst str = arr.some((currentValue) => {\n\tconsole.log(currentValue)\n\treturn currentValue > 1\n})\n// 1\n// 2\nconsole.log(str) // true\n```\n> **arr.every((currentValue , index , arr) => {},  thisValue) 判断数组中的每一项是否都满足条件，全部符合就会返回true，否则false。**\n\n```\nconst arr = [1, 2, 3]\nconst str = arr.every((currentValue) => {\n\treturn currentValue > 1\n})\nconsole.log(str) // false\n```\n### 12. reduce()、reduceRight() 归并方法，不改变原数组\n- 这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数，第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组，函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。\n- [total] 必须项，初始值, 或者计算结束后的返回值。\n- [cur] 必须项，当前元素。\n- [index] 可选。当前元素的索引值\n- [arr] 可选。当前元素所属的数组对象\n- [initialValue] 可选。传递给函数的初始值。\n> **arr.reduce((total , cur , index , arr) => {}, initialValue) 从数组的第一项开始，逐个遍历到最后**\n> **arr.reduceRight((total , cur , index , arr) => {}, initialValue) 从数组的最后一项开始，向前遍历到第一项**\n```\nconst arr = [1,2,3,4,5]\nconst result1 = arr.reduce((total,cur,index,arr) => {\t\n\tconsole.log(\"total:\" + total + \",cur:\" + cur + \",index:\" + index)\n    return total + cur\n})\nconsole.log(\"结果：\" + result1)\n// 输出\n// total:1,cur:2,index:1\n// total:3,cur:3,index:2\n// total:6,cur:4,index:3\n// total:10,cur:5,index:4\n// 结果：15\nconst result2 = arr.reduce((total,cur,index,arr) => {\t\n\tconsole.log(\"total:\" + total + \",cur:\" + cur + \",index:\" + index)\n    return total + cur\n},10)\nconsole.log(\"结果：\" + result2)\n// 输出\n// total:10,cur:1,index:0\n// total:11,cur:2,index:1\n// total:13,cur:3,index:2\n// total:16,cur:4,index:3\n// total:20,cur:5,index:4\n// 结果：25\n```\n- 从上面代码我们可以看出，当我们不给函数传递迭代初始值时初始值 total 为数组第一项，函数从数组第二项开始迭代；若我们给函数传递迭代初始值，则函数从数组第一项开始迭代。\n\n### 13.  keys()、values()、entries() 遍历数组方法,不改变原数组。 ==（es6新增方法）==\n> **keys() 对键名的遍历**\n\n```\nconst arr = [\"a\",\"b\",\"c\",\"d\"]\nfor(let i of arr.keys()){\n\tconsole.log(i)\n}\n//打印：\n// 0\n// 1\n// 2\n// 3\n\n```\n> **values()对键值的遍历**\n\n```\nconst arr = [\"a\",\"b\",\"c\",\"d\"]\nfor(let i of arr.values()){\n\tconsole.log(i)\n}\n//打印：\n// a\n// b\n// c\n// d\n\n\n```\n> **entries()是对键值对的遍历。**\n\n```\nconst arr = [\"a\",\"b\",\"c\",\"d\"]\nfor(let i of arr.entries()){\n\tconsole.log(i)\n}\n//打印：\n// [0, \"a\"]\n// [1, \"b\"]\n// [2, \"c\"]\n// [3, \"d\"]\nfor(let [idx,item] of arr.entries()){\n    console.log(idx + \":\"+item)\n}\n//打印：\n// 0:a\n// 1:b\n// 2:c\n// 3:d\n\n```\n### 14. includes() 不改变原数组。 ==（es6新增方法）==\n> **arr.includes(searchElement ,  fromIndex) 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。**\n\n- [searchElement] 可选。需要查找的元素值。\n- [fromIndex] 可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。\n```\nconst arr = [\"a\",\"b\",\"c\",\"d\"]\nconst result1 = arr.includes(\"b\")\nconst result2 = arr.includes(\"b\",2)\nconst result3 = arr.includes(\"b\",-1)\nconst result4 = arr.includes(\"b\",-3)\nconsole.log(result1)  // true\nconsole.log(result2)  // false\nconsole.log(result3)  // flase\nconsole.log(result4)  // true\n```\n### 15. Array.from() ==（es6新增方法）==\n> **Array.from() 用于类似数组的对象（即有length属性的对象）和可遍历对象转为真正的数组。**\n\n```\nconst json ={\n    '0':'喜',\n    '1':'欢',\n    '2':'你',\n    length:3\n}\nconst arr = Array.from(json)\nconsole.log(arr) // [\"喜\", \"欢\", \"你\"]\t\n\n```\n### 16. Array.of()  ==（es6新增方法）==\n> **Array.of() 将一组值转变为数组，参数不分类型，只分数量，数量为0返回空数组。**\n\n```\nlet arr1 = Array.of(1,2,3)\nlet arr2 = Array.of([1,2,3])\nlet arr3 = Array.of(undefined)\nlet arr4 = Array.of()\nconsole.log(arr1) // [1, 2, 3]\nconsole.log(arr2) // [[1, 2, 3]]\nconsole.log(arr3) // [undefined]\nconsole.log(arr4) // []\n\n```\n### 17. fill() 改变原数组。 ==（es6新增方法）==\n> **arr.fill(value,  start,  end) 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。**\n\n- [value] 必需。填充的值。\n- [start] 可选。开始填充位置。如果这个参数是负数，那么它规定的是从数组尾部开始算起。\n- [end] 可选。停止填充位置 (默认为 array.length)。如果这个参数是负数，那么它规定的是从数组尾部开始算起。\n```\nlet arr = [1,2,3,4,5,6]\narr.fill(0)  // [0, 0, 0, 0, 0, 0]\narr.fill(0,1)  // [1, 0, 0, 0, 0, 0] \narr.fill(0,1,2)  // [1, 0, 3, 4, 5, 6]\narr.fill(0,-1)  // [1, 2, 3, 4, 5, 0]\narr.fill(0,1,-1)  // [1, 0, 0, 0, 0, 6]\n\n```\n### 18. copyWithin() 不改变原数组。 ==（es6新增方法）==\n> **arr.copyWithin(target,  start,  end) 用于从数组的指定位置拷贝元素到数组的另一个指定位置中，会覆盖原有成员。**\n\n- [target] 必需。从该位置开始替换数据。\n- [start] 可选。从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。\n- [end] 可选。到该位置前停止读取数据 (默认为 array.length)。如果为负值，表示倒数。\n```\nlet arr = [1,2,3,4,5,6]\nlet result1 = [1,2,3,4,5,6].copyWithin(0)\nlet result2 = [1,2,3,4,5,6].copyWithin(0,1)\nlet result3 = [1,2,3,4,5,6].copyWithin(1,3,5)\nlet result4 = [1,2,3,4,5,6].copyWithin(1,2,-1)\nlet result5 = [1,2,3,4,5,6].copyWithin(1,-4,6)\nconsole.log(result1)  // [1, 2, 3, 4, 5, 6]\nconsole.log(result2)  // [2, 3, 4, 5, 6, 6]\nconsole.log(result3)  // [1, 4, 5, 4, 5, 6]\nconsole.log(result4)  // [1, 3, 4, 5, 5, 6]\nconsole.log(result5)  // [1, 3, 4, 5, 6, 6]\n\n```",
    "tagIds": "5,12,11",
    "author": "菜头",
    "authorAvatar": "http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif",
    "weight": 1,
    "type": 1,
    "groupTimestamp": "1549548067227",
    "cover": "https://img-blog.csdnimg.cn/20210127143421666.png",
    "categoryId": 1,
    "created_at": "2023-11-06T14:06:54.000Z",
    "updated_at": "2023-11-06T14:06:54.000Z",
    "tagList": [
        {
            "id": 5,
            "name": "ECMAScript"
        },
        {
            "id": 11,
            "name": "JavaScript"
        },
        {
            "id": 12,
            "name": "ES6"
        }
    ],
    "createDate": "2019-02-07"
}