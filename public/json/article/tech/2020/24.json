{"id":24,"title":"打造vuecli3+element后台管理系统（五）几个小技巧，让你的后台系统在不同版本浏览器兼容性更好","subTitle":"浏览器兼容","link":null,"description":"在开发时我们都习惯在google浏览器进行调试，总所周知，google浏览器的对css3、html5、es6等的支持是完全没有问题的，所以我们会忽略了其实在其他浏览器对这些新特性不够支持的问题，下面介绍我在开发后台系统中使用的一些插件和一些小技巧，来让你的后台系统尽可能多的向下向外兼容多版本浏览器~","content":"> 当你的后台系统写好，给测试大大验收的时候。会发现他甩了一堆兼容性bug给你，在ie中打不开页面啦、在360浏览器火狐ie布局混乱啦、输入框怎么有难看的黄色背景啦、电话输入框怎么有丑陋的箭头啦、字体溢出了啦等等等等...\n\n### 一、用rem代替px\n许多后台系统都要求要做成响应式的，虽然我们用的elementUI框架已经在响应式上面做了出色的处理，但是也只能解决一部分的问题。所以我们需要使用rem。\n\n#### 1.1 什么是rem\nrem是CSS3新增的相对长度单位，是指相对于根元素html的font-size计算值的大小。简单可理解为屏幕宽度的百分比。\n\n但是！但是！问题来了，那就是我们其实用px开发习惯了，要改成rem一时半会缓不过来，加上还要换算是吧。所以用rem还挺烦的。接下来主角就登场了，安利大家几个插件，能够将你项目中的px转换成rem，还可以自定义换算基数等。\n\n#### 1.2 使用lib-flexible & px2rem自动转换px为rem，解决响应式问题\n\n##### 1.2-1 引入lib-flexible 和 px2rem\n```bash\nnpm install --save lib-flexible\nnpm install --save-dev px2rem-loader postcss-plugin-px2rem\n```\n\n```!\npostcss-plugin-px2rem 是为了在使用less或者sass的情况下也可以正常转换\n```\n\n##### 1.2-2 删除或注释index.html中的 ```<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">``` 标签\n\n使用lib-flexible插件，他会自动生成meta name=\"viewport\"的标签，所以我们需要把原来有的删除掉。自动生成标签之后，lib-flexible会自动设置html的font-size为屏幕宽度除以10，也就是1rem等于html根节点的font-size，如果你的设计稿宽度是750px，那font-size就会被设置为75px\n\n``` html\n  <head>\n    <!-- <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"> -->\n  </head>\n\n```\n\n##### 1.2-3 入口文件引入lib-flexible\n在main.js全局引入lib-flexible\n```javascript\n// 使用lib-flexible来解决移动端适配\nimport 'lib-flexible'\n```\n\n##### 1.2-4 新增配置\n在vue.config.js新增px2rem的配置\n```javascript\nconst path = require('path')\n\nfunction resolve(dir) {\n  return path.join(__dirname, dir)\n}\n\nmodule.exports = {\n  publicPath: '/',\n  outputDir: 'dist', // 输出文件目录\n  assetsDir: 'assets', // 静态资源文件夹\n  productionSourceMap: false,\n  devServer: {\n    port: 9566, // 端口号\n    open: true,\n    proxy: null // 设置代理\n  },\n  // 新增内容\n  css: {\n    loaderOptions: {\n      sass: { // 如果用的是less就改成less\n        javascriptEnabled: true\n      },\n      postcss: {\n        plugins: [\n          require('postcss-plugin-px2rem')({\n            rootValue: 54, // 换算基数，默认100，自行根据效果调整。\n            mediaQuery: false, // （布尔值）允许在媒体查询中转换px。\n            minPixelValue: 3 // 设置要替换的最小像素值默认0，这里表示大于3px会被转rem。\n          })\n        ]\n      }\n    }\n  },\n  // 新增结束\n  chainWebpack: config => {\n    // 新增内容\n    config.module\n      .rule('css')\n      .test(/\\.css$/)\n      .oneOf('vue')\n      .resourceQuery(/\\?vue/)\n      .use('px2rem')\n      .loader('px2rem-loader')\n      .options({\n        remUnit: 54\n      })\n    // 新增结束\n\n    config.module\n      .rule('svg')\n      .exclude.add(resolve('src/icons'))\n      .end()\n\n    config.module\n      .rule('icons')\n      .test(/\\.svg$/)\n      .include.add(resolve('src/icons'))\n      .end()\n      .use('svg-sprite-loader')\n      .loader('svg-sprite-loader')\n      .options({\n        symbolId: 'icon-[name]'\n      })\n  }\n}\n```\n\n##### 1.2-5 康康postcss-plugin-px2rem的配置项\n官方文档给出的配置项有这么多：\n```json\n{\n  rootValue: 100,\n  unitPrecision: 5,\n  propWhiteList: [],\n  propBlackList: [],\n  exclude:false,\n  selectorBlackList: [],\n  ignoreIdentifier: false,\n  replace: true,\n  mediaQuery: false,\n  minPixelValue: 0\n}\n```\n\n我们目前只用到了三个\n那么这些都是啥意思呢，一起来康康\n\n- **rootValue** 转换基数，类型可以是Number也可以是Object，默认是100\n    - 如果你传的是一个Object，例如 ```{ px: 50, rpx: 100 }``` ，那么就意味着，在换算的时候，如果遇上单位是px那换算基数是50，如果遇上rpx那么换算基数是100\n- **unitPrecision** 单位精度，Number类型，简单的说就是转换之后的rem要保留几位小数，默认保留5位的哈\n- **propWhiteList** 转换的白名单，Array类型，里面包含了可以被转换的css属性\n    - 默认是个空数组哦， 意思就是不用呗，就是说css里所有的属性，都可以进行转换\n    - 里面的属性值必须精确匹配，使用了白名单之后，意味着只有白名单里头的属性可以转换了。感觉这个白名单会比较少用到的说\n- **propWhiteList** 转换的黑名单，和白名单相反嘛，黑名单里头的css属性是不会进行转换的\n- **exclude** 排除的文件夹，是正则表达式。比如说写了``` /(node_module)/```，就是说(node_module)中的样式文件不进行替换，这文件夹里能有啥，就是你引的插件嘛。排除这个文件夹的意思就是不对你引入的UI框架的样式进行单位转换。\n- **selectorBlackList** 选择器黑名单，Array类型。和上面那个属性黑名单大同小异，不同的是这里忽略转换的依据是css选择器。\n    - 如果是['body']，数组元素是单纯的字符串，意思就是排除class为body的转换，即忽略.body下的所有属性的转换。\n    - 如果是[/^body$/]酱的，数组元素是一个正则表达式，他排除的就是body标签，即忽略body标签下的所有属性的转换。\n- **ignoreIdentifier** 默认是false，也可以是String类型，当是某个css属性名的时候，意思就是忽略这个属性的转换。如果你想忽略的属性只有那么一个，而不是一连串的时候，就可以用它。当启用这个的时候，replace会自动变成true的哈\n- **replace** 默认是true，Boolean类型，表示直接替换包含REM的规则，而不是添加回调函数\n- **mediaQuery** Boolean类型，默认是false，表示是否允许在@media查询中进行转换\n- **minPixelValue** Number类型，表示开始转换的最小值，默认是0，意思就是大于0px的长度都进行转换\n\n-----------------------------------------------\n\n```!\n细心的小伙伴发现我这里的rootValue转换基数设置的是54，为什么涅？你运行项目，然后F12，会发现根元素html的font-size是54px。为什么！为什么明明前面说的是宽度除以10啊，我特喵的pc端宽度是1080啊，不应该是font-size:108px么？？？\n```\n> 想知道答案的小伙伴就要去看看伟大的lib-flexible的源码啦，lib-flexible里头有这么一段代码：\n\n```js\nfunction refreshRem(){\n    var width = docEl.getBoundingClientRect().width;\n    if (width / dpr > 540) {\n        width = 540 * dpr;\n    }\n    var rem = width / 10;\n    docEl.style.fontSize = rem + 'px';\n    flexible.rem = win.rem = rem;\n}\n```\n\n> pc端的dpr是1，width / dpr肯定是大于540的，所以lib-flexible会默认使用540px这个宽度，然后将屏幕宽度除以10作为rem值，所以1rem = 54px。所以我们将rootValue转换基数设为54刚刚好\n\n-----------------------------------------------\n\n康康添加了lib-flexible & px2rem之后，页面在移动端的显示效果如何：\n\n![inPhone1](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cf1e454cf9c5db~tplv-t2oaga2asx-image.image)\n\n![inPhone2](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cf1e47d6800334~tplv-t2oaga2asx-image.image)\n\n好的，十分优秀。\n\n### 二、解决低版本ie打不开页面的问题\n\n当你写完后台系统之后，毛闷台了喔，在线上把代码一拉一部署，测试那边说了，你这个页面我浏览器打不开啊！你过去之后发现他用的ie不知道6还是7还是8测得你的网站。那么问题来了，为什么会打不开呢？\n\n原因就是你的项目里头用了es6的promise，ie低版本对这个的支持不是特别好，这个问题很好解决，只需要引入两个插件就可以了。对本身代码没有其他影响。\n\n#### 2.1 引入es6-promise & 和babel-polyfill依赖包\n```bash\nnpm install --save es6-promise babel-polyfill\n```\n\n#### 2.2 在入口文件main.js引入\n```javascript\n// 解决低版本浏览器不支持promise问题\nimport 'babel-polyfill'\nimport Es6Promise from 'es6-promise'\nEs6Promise.polyfill()\n```\n\n#### 2.3 在vue.config.js新增配置\n```javascript\n    // 。。。此处省略n个字符。。。\n    config.module\n      .rule('icons')\n      .test(/\\.svg$/)\n      .include.add(resolve('src/icons'))\n      .end()\n      .use('svg-sprite-loader')\n      .loader('svg-sprite-loader')\n      .options({\n        symbolId: 'icon-[name]'\n      })\n    // 新增配置\n    config.entry.app = ['babel-polyfill', './src/main.js']\n    // 新增结束\n  }\n}\n```\n\n### 三、使用autoprefixer让css属性自动增加兼容前缀\n很多时候，像flexBox或者transform这样样式，在不同浏览器下面有不同的写法，正常来说我们每次用到其中一个的时候都需要写这么长一大串：\n```html\n<style lang=\"scss\">\n.flex-box {\n    display: -webkit-box;\n    display: -moz-box;\n    display: -webkit-flex;\n    display: -moz-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-justify-content: center;\n    -webkit-box-pack: center;\n    -moz-justify-content: center;\n    -moz-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    -webkit-align-items: center;\n    -webkit-box-align: center;\n    -moz-align-items: center;\n    -moz-box-align: center;\n    -ms-flex-align: center;\n    align-items: center;\n    -webkit-box-direction: normal;\n    -webkit-box-orient: vertical;\n    -webkit-flex-direction: column;\n    -moz-flex-direction: column;\n    -moz-box-orient: vertical;\n    -ms-flex-direction: column;\n    flex-direction: column;\n}\n</style>\n```\n晕，我只是想要用一下flex布局啊。。\n\n经过评论区小伙伴的提醒，这里有一个很棒的插件可以使用，他可以自动给你的项目增加兼容前缀，需要添加的浏览器兼容前缀由你自由配置。我们只需：\n\n#### 3.1安装autoprefixer依赖\n```bash\ncnpm install --save-dev autoprefixer\n```\n\n#### 3.2在vue.config.js引入\n```javascript\n// ...省略前面省略\ncss: {\n    loaderOptions: {\n      sass: { // 如果用的是less就改成less\n        javascriptEnabled: true\n      },\n      postcss: {\n        plugins: [\n          // 新增内容\n          require('autoprefixer')({}),\n          // 新增结束\n          require('postcss-plugin-px2rem')({\n            rootValue: 54, // 换算基数，默认100，自行根据效果调整。\n            mediaQuery: false, // （布尔值）允许在媒体查询中转换px。\n            minPixelValue: 3 // 设置要替换的最小像素值默认0，这里表示大于3px会被转rem。\n          })\n        ]\n      }\n    }\n  },\n // ...省略后面省略\n```\n\n#### 3.3 在package.json中指定browserslist关键字\n在package.json中新增\n```json\n\"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\",\n    \"not ie <= 8\",\n    \"iOS >= 8\",\n    \"Firefox >= 20\",\n    \"Android >= 4.4\"\n  ]\n```\n\n接下来就是见证奇迹的时刻，重新npm run serve一下，你就发现所有兼容样式前面都加上前缀啦~\n\n--------------------------------------------\n```!\n关于之前的手写mixin的方法，我还是建议大家能够多封装，不管是业务代码上还是样式代码上，这样可以增加代码的复用率，让你的代码看起来更加轻盈。像一些使用率比较多的样式块，可以使用mixin封装起来，需要时include就行啦，也是十分方便的。\n```\n\n**举个栗子**\n1. 在styles的mixin.scss文件里声明一些常用的样式块\n```css\n/* 背景自适应容器大小 */\n@mixin bgCover($url) {\n  background-image: url($url);\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-position: 0 center;\n}\n\n@mixin noData($url) {\n  width: 100%;\n  font-size: 14px;\n  text-align: center;\n  color: #666;\n  line-height: 60px;\n}\n```\n\n2. 在需要使用到mixin样式的页面引入，用mixin替换样式块\n```html\n<style lang=\"scss\">\n@import '~@/styles/mixin';\n.no-data {\n    @include noData;\n}\n</style>\n```\n--------------------------------------------\n\n### 四、覆盖默认样式\n很多标签都有一些奇奇怪怪的默认样式，在不同的浏览器下面默认样式还不一样，为了统一性。我们需要覆盖掉默认样式。其实这一块，elementUI已经考虑到了，在styles目录下面的index.scss文件就是用来覆盖默认样式的。有需要覆盖掉的默认样式，可以在里面已有代码的基础上再新增。分享两个典型的：\n\n#### 4.1 覆盖掉input type=number时的箭头\n```css\ninput::-webkit-outer-spin-button,\ninput::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n}\ninput[type=\"number\"] {\n  -moz-appearance: textfield;\n}\n```\n\n#### 4.2 改变Placeholder文字的颜色\n```css\ninput::-moz-placeholder{color:rgb(204, 204, 204)} //Firefox\ninput::-webkit-input-placeholder{color:rgb(204, 204, 204)} //Chrome,Safari\ninput:-ms-input-placeholder{color:rgb(204, 204, 204)} // ie\ntextarea::-moz-placeholder{color:rgb(204, 204, 204)} //Firefox\ntextarea::-webkit-input-placeholder{color:rgb(204, 204, 204)} //Chrome,Safari\ntextarea:-ms-input-placeholder{color:rgb(204, 204, 204)} // ie\n```\n\n### 五、通过meta标签控制浏览器内核\n国产浏览器大多是双内核，甚至更多，例如360浏览器、QQ浏览器之类。这些浏览器一般会有一个Chromium内核（极速模式。Chromiu就是Chrome使用的内核。）；一个IE内核（IE模式）；有的甚至还有一个修改过的IE内核（兼容模式）。\n\n我们创建的项目，默认有一个控制切换浏览器内核的meta标签```<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">```运行网站的时候强制切换为该浏览器所拥有的最高版本IE内核，所以在qq浏览器或者360浏览器里头打开项目，会发现浏览器用的是IE模式或者兼容模式。\n\n因为项目是用chrome调试的，所以在Chromium内核下拥有最优体验，我们需要用代码让浏览器能够改变一下模式。具体做法就是：\n\n#### 修改public目录下的index.html模板文件。\n> 新增meta标签，告诉浏览器优先使用何种内核\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    \n    <!-- 新增内容 -->\n    <!-- 强制Chromium内核，作用于360浏览器、QQ浏览器等国产双核浏览器 -->\n    <meta name=\"renderer\" content=\"webkit\"/>\n    <!-- 强制Chromium内核，作用于其他双核浏览器 -->\n    <meta name=\"force-rendering\" content=\"webkit\"/>\n    <!-- 如果有安装 Google Chrome Frame 插件则强制为Chromium内核，否则强制本机支持的最高版本IE内核，作用于IE浏览器 -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\"/>\n    <!-- 新增结束 -->\n    \n    <!-- <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"> -->\n    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n    <title>vuecli3-ele-admin-template</title>\n  </head>\n  <body>\n    <noscript>\n      <strong>We're sorry but vuecli3-ele-admin-template doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n    <!-- built files will be auto injected -->\n  </body>\n</html>\n```\n清一下浏览器缓存，重新运行项目，就会发现在360浏览器、QQ浏览器下已经变成Chromium内核的极速模式了~美得很~\n\n\n暂时就先想到这些啦，后面想到我再继续补充~~\n还有很多细节的东西没有详细写出来，我这里贴一下项目地址，有兴趣的可以看一看哦～\n\n- [x] [一个基于vuecli3和vue-admin-template改造的响应式后台管理系统](https://github.com/ccccai/vuecli3-ele-admin-template)","tagIds":"4,7,10,11,12,31,21","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":99,"type":1,"groupTimestamp":"1581283181822","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cf21588a45126a~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:21:00.000Z","updated_at":"2023-11-23T10:17:55.000Z","tagList":[{"id":4,"name":"CSS"},{"id":7,"name":"LESS"},{"id":10,"name":"HTML"},{"id":11,"name":"JavaScript"},{"id":12,"name":"ES6"},{"id":21,"name":"px2rem"},{"id":31,"name":"JQuery"}],"createDate":"2020-02-10"}