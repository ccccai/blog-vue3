{
    "id": 3,
    "title": "在laravel中使用redis队列，发送邮件",
    "subTitle": "php是这个世界上最好的语言！[doge]",
    "link": null,
    "description": "在开发过程中遇到了需要使用队列发送邮件的需求，故记录一小下",
    "content": "## 一、驱动的选择\n\n### 1、使用数据库驱动\n\n优点：不用安装其他的啦里啦杂的东西，直接用\n\n缺点：要进行数据库迁移，产生工作数据表\n\n#### 1-1 .env文件中设置队列驱动为数据库\n\n``` bash\nphp artisan queue:table\n```\n\n\n#### 1-2 创建队列用到的数据表\n\n``` bash\nphp artisan queue:table\n```\n\n\n#### 1-3 执行migrate\n\n``` bash\n# 会新建 database/migrations/{timestamp}_create_jobs_table.php 文件\nphp artisan migrate\n```\n\n\n#### 1-4 .env文件示例\n\n```\nBROADCAST_DRIVER=log\nCACHE_DRIVER=file\nSESSION_DRIVER=file\nQUEUE_DRIVER=database\n\nREDIS_HOST=127.0.0.1\nREDIS_PASSWORD=null\nREDIS_PORT=6379\n\nMAIL_DRIVER=smtp\nMAIL_HOST=smtp.exmail.qq.com // QQ企业邮箱\nMAIL_PORT=25 // 使用25端口\nMAIL_USERNAME=xxxx@xxx.com // 发件人邮箱\nMAIL_PASSWORD=*** // 密码或授权码\nMAIL_ENCRYPTION=tls\n```\n\n### 2、使用redis驱动\n\n#### 2-1 安装redis\n\n* windows下\n\n[windows下载地址](https://github.com/MSOpenTech/redis/releases)，下载运行安装即可。\n\n![64bit-redis](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/15/16c944bdcd4cd4d2~tplv-t2oaga2asx-image.image)\n\n打开一个cmd窗口使用cd命令切换目录到```C:\\redis```运行```redis-server.exe redis.windows.conf```\n\n* Linux下\n\n``` bash\n# 看看有木有密码\n/etc/redis.conf port6379\n```\n\n#### 2-1 项目中使用  Composer 安装依赖\n\n``` bash\ncomposer require \"predis/predis:~1.0\" \n```\n\n#### 2-3 .env文件示例\n\n```\nDB_CONNECTION=mysql\nDB_HOST=localhost\nDB_PORT=3306\nDB_DATABASE=honeybot\nDB_USERNAME=root\nDB_PASSWORD=root\n\nBROADCAST_DRIVER=log\nCACHE_DRIVER=file\nSESSION_DRIVER=file\nQUEUE_DRIVER=redis\n\nREDIS_HOST=127.0.0.1\nREDIS_PASSWORD=null\nREDIS_PORT=6379\n\nMAIL_DRIVER=smtp\nMAIL_HOST=smtp.exmail.qq.com\nMAIL_PORT=465 // 使用465端口\nMAIL_USERNAME=xxx@xxx.com\nMAIL_PASSWORD=***\nMAIL_ENCRYPTION=ssl // 使用465端口\n```\n\n\n## 二、失败任务记录（可有可无，看你自己想不想记录）\n\n有时候队列中的任务会失败。Laravel 内置了一个方便的方式来指定任务重试的最大次数。当任务超出这个重试次数后，它就会被插入到 failed_jobs 数据表里面。我们可以使用```queue:failed-table```命令来创建 failed_jobs 表的迁移文件\n\n``` bash\n# 会新建 database/migrations/{timestamp}_create_failed_jobs_table.php 文件\n php artisan queue:failed-table\n ```\n \n 接着使用 migrate Artisan 命令生成 failed_jobs 表：\n ``` bash\n php artisan migrate\n ```\n \n## 三、创建任务\n\n创建任务 = 搞一个生产者 = （其实就是写一个在队列中你想执行的业务逻辑）,名字随意取，但最好遵守命名规范。\n \n这个生成的文件大概分2部分：一是__construct() 构造方法 ；二是handle 队列执行方法(意思就是在队列执行的时候，就用你这里面写的代码)\n \n### 1、使用以下 Artisan 命令来生成一个新的队列任务：\n\n ``` bash\n # 该命令会在 app/Jobs 目录下生成一个新的类\n php artisan make:job SendReminderEmail\n ```\n\n新生成的类：pp/Jobs/SendReminderEmail.php\n ``` php\n <?php\n\nnamespace App\\Jobs;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse App\\Util\\L;\nuse Mail;\n\nclass SendReminderEmail implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n    protected $orderInfo;\n    protected $email;\n\n    /**\n     * Create a new job instance.\n     *\n     * @return void\n     */\n    public function __construct($orderInfo, $email)\n    {\n        $this->orderInfo = $orderInfo;\n        $this->email = $email;\n    }\n\n    /**\n     * Execute the job.\n     *\n     * @return void\n     */\n    public function handle()\n    {\n        // Mail::send()的返回值为空，所以可以其他方法进行判断\n        Mail::send('emails.new_order_mail',\n            [\n                'order_number' => $this->orderInfo['order_number'],\n                'goods_name' => $this->orderInfo['goods_name'],\n                'goods_color' => $this->orderInfo['goods_color'],\n                'goods_num' => $this->orderInfo['goods_num']\n            ],\n            function ($message) {\n                $to = $this->email;\n                $message->to($to)->subject('【xx商城新订单通知】');\n            });\n        // 返回的一个错误数组，利用此可以判断是否发送成功\n        if (count(Mail::failures()) >= 1) {\n            L::email(\"订单：\" . $this->orderInfo['order_number'] . \"的 \" . $this->email . \" 邮件通知发送失败\");\n        }\n    }\n}\n ```\n \n### 2、任务分发\n \n#### 2-1 生产者，在控制器内使用dispatch方法调用即可\n\n``` php\n <?php\n\nnamespace App\\Api\\Controllers\\Mail;\nuse App\\Api\\Controllers\\BaseController;\nuse App\\Repositories\\Order\\OrderRepository;\n\nclass MailController extends BaseController\n{\n    public function __construct(OrderRepository $order)\n    {\n        $this->order = $order;\n    }\n\n    public function send()\n    {\n        $header_id = 3691;\n        $this->order->sendMail($header_id);\n    }\n}\n```\n \n\n#### 2-2 定义发送邮件的类，分发任务\n\n ``` bash\n /**\n     * @param $header_id\n     * @return mixed\n     * 发送邮件 队列\n     */\n    public function sendMail($header_id)\n    {\n        try {\n            // 邮件内容\n            $orderInfo = OrderDetail::select('order_number', 'order_lines.*')\n                ->leftJoin('order_headers', 'order_headers.uid', '=', 'header_id')\n                ->where('header_id', $header_id)\n                ->first();\n            $order['order_number'] = $orderInfo->order_number;\n            $order['goods_name'] = '嘻嘻' . $orderInfo->combo;\n            $order['goods_color'] = $orderInfo->color;\n            $order['goods_num'] = $orderInfo->quantity;\n            L::email(\"订单：\" . $orderInfo->order_number);\n            // 邮件地址列表\n            $emailList = [\"xxx@qq.com\", \"xxx@163.com\"]; // 测试 邮件地址\n            // 推送任务入队列\n            foreach ($emailList as $email) {\n                dispatch(new SendReminderEmail($order, $email));\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n ```\n\n#### 2-3 新建邮件发送模板\n\n``` php\n// /resource/views/emailsnew_order_mail.blade.php\n<div>你好，小程序商城收到新订单。</div>\n<div>收货地址: {{$address}}</div>\n<div>订单号: {{$order_number}}</div>\n<div>商品名称: {{$goods_name}}</div>\n<div>商品颜色: {{$goods_color}}</div>\n<div>数量: {{$goods_num}}</div>\n```\n\n## 四、开始测试\n\n开始之前，我们需要在命令行启动队列系统，队列在启动完成后会进入监听状态\n\n``` bash\nphp artisan queue:listen\n```\n\n## 五、运行队列进程\n\n``` bash\nphp artisan queue:work\n```\n\n## 六、配置 Supervisor\n\n测试完成后，邮件发送成功，表示你已经成功啦~\n\nbut，如果是在生产环境，就不可能是像开发时启动一下队列发送一次，肯定是要有一定的监听和触发机制，所以Supervisor登场了。\n\nsupervisord 是进程管理的服务端，常驻进程辅助干活\nsupervisorctl 是客户端，用来执行查看、加载等命令\n\n具体请看[配置 Supervisor，linux下的队列进程管理服务端](https://juejin.im/post/6844903914039410695)",
    "tagIds": "20",
    "author": "菜头",
    "authorAvatar": "http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif",
    "weight": 1,
    "type": 1,
    "groupTimestamp": "1565878336520",
    "cover": "https://logos-download.com/wp-content/uploads/2016/09/Laravel_logo_wordmark_logotype.png",
    "categoryId": 2,
    "created_at": "2023-11-06T14:17:09.000Z",
    "updated_at": "2023-11-06T15:31:51.000Z",
    "tagList": [
        {
            "id": 20,
            "name": "PHP"
        }
    ],
    "createDate": "2019-2-15"
}