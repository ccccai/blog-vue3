{"id":19,"title":"在koa中对操作文件","subTitle":"对指定目录下的文件进行读写、删除、追加等操作","link":null,"description":"最近写博客，希望在本地用Markdown编写好文档并保存到数据库的时候，能够同时输出静态json文件来上传到github中，故小小研究了一下，记录一下各种方法","content":"这次在koa中对文件进行操作，主要是使用了nodejs中的fs模块，下面我将详细介绍一下fs的各种方法示例。\n\n## 一、fs简述\nfs中的所有方法都用异步和同步两种形式。\n\n异步形式始终以完成后的回调函数作为它的最后一个参数。传给回调函数的参数取决于具体方法，但第一个参数总是留给异常字段，如果操作是成功的，那么第一个异常字段会返回null或undefined。\n\n```js\nconst fs = require('fs)\nfs.unlink('/test', function(err){\n if (err) {\n  throw err\n }\n console.log('success')\n})\n```\n\n当使用同步形式时，任何异常都会被立即抛出。可以使用`try/catch`来处理异常，或者让他们往上冒泡。\n\n```js\nconst fs = require('fs)\nfs.unlinkSync('/test')\nconsole.log('success')\n```\n\n异步方法不保证执行顺序。 所以下面的例子容易出错\n\n```js\nfs.rename('/tmp/hello', '/tmp/world', function(err){\n if (err) throw err\n console.log('renamed complete')\n})\n\nfs.stat('/tmp/world', function(err, stats){\n if (err) throw err\n console.log('stats: ${JSON.stringify(stats)}')\n})\n```\n\nfs.stat 可能在 fs.rename 之前执行。正确的方法是把回调链起来\n\n```js\nfs.rename('/tmp/hello', '/tmp/world', function(err){\n if (err) throw err\n fs.stat('/tmp/world', function(err, stats){\n  if (err) throw err\n  console.log('stats: ${JSON.stringify(stats)}')\n })\n})\n```\n\n推荐使用这些函数的异步版本，同步版本会阻塞整个进程，直到它们完成（停止所有连接）。\n\n## 二、fs底层操作\n\n### 1、打开文件\n\n#### 1-1 异步：`fs.open(path, flags[mode], callback)`\n\n参数如下：\n\n* path: \\<String> | \\<Buffer>\n* flags: \\<String> | \\<Number>\n* mode: \\<Integer> 设置文件模式（权限和 sticky 位），但只有当文件被创建时才有效。默认为 0666，可读写\n* callback: \\<Function> 该回调有两个参数 (err错误, fd文件标识，与定时器标识类似)\n\nflags可以是：\n* 'r' - 以读取模式打开文件。如果文件不存在则发生异常。\n\n* 'r+' - 以读写模式打开文件。如果文件不存在则发生异常。\n\n* 'rs+' - 以同步读写模式打开文件。命令操作系统绕过本地文件系统缓存。\n\n* 'w' - 以写入模式打开文件。文件会被创建(如果文件不存在)或截断(如果文件存在)。\n\n* 'wx' - 类似 'w'，但如果 path 存在，则失败。\n\n* 'w+' - 以读写模式打开文件。文件会被创建(如果文件不存在)或截断(如果文件存在)。\n\n* 'wx+' - 类似 'w+'，但如果 path 存在，则失败。\n\n* 'a' - 以追加模式打开文件。如果文件不存在，则会被创建。\n\n* 'ax' - 类似于 'a'，但如果 path 存在，则失败。\n\n* 'a+' - 以读取和追加模式打开文件。如果文件不存在，则会被创建。\n\n* 'ax+' - 类似于 'a+'，但如果 path 存在，则失败。\n\n**注意：使用`'rs+'`模式不会使`fs.open()`进入同步阻塞调用。如果那是你想要的，则应该使用`fs.openSync()`**\n\n```js\nconst fs = require('fs');\n \nfs.open('a.txt','r',function(err,fs){\n  console.log(err) // null\n  console.log(fs) // 3\n})\n\nfs.open('b.txt','r',function(err,fs){\n/*\n{ Error: ENOENT: no such file or directory, open 'D:\\project\\b.txt'\n  at Error (native)\n errno: -4058,\n code: 'ENOENT',\n syscall: 'open',\n path: 'D:\\\\project\\\\b.txt' }\n */\n  console.log(err)\n  console.log(fs) // undefined\n})\n```\n\n文件的回调函数中的第二个参数fd代表文件标识，与定时器标识类似，用于标识文件，且随着文件的打开顺序递增\n\n```js\nconst fs = require('fs');\n \nfs.open('1.txt','r',function(err,fs){\n  console.log(fs) // 3\n})\n \nfs.open('2.txt','r',function(err,fs){\n  console.log(fs) // 4\n})\n```\n\n#### 1-2 同步：`fs.openSync(path, flags[mode])`\nfs.open() 的同步版本，返回一个表示文件描述符的整数。\n\n```js\nconst fs = require('fs');\nconst result = fs.openSync('1.txt','r')\nconsole.log(result) // 3\n```\n\n### 2、读取文件\n\n#### 2-1 `fs.read(fd, buffer, offset, length, position, callback)`\n\n参数如下：\n\n* fd \\<Integer> 通过 fs.open() 方法返回的文件描述符\n\n* buffer \\<String> | \\<Buffer> 数据将被写入到buffer\n\n* offset \\<Integer> buffer中开始写入的偏移量\n\n* length \\<Integer> 指定要读取的字节数(整数)\n\n* position \\<Integer> 指定从文件中开始读取的位置(整数)。 如果position为null，则数据从当前文件位置开始读取\n\n* callback \\<Function> 回调有三个参数 (err, bytesRead, buffer)。err为错误信息，bytesRead表示读取的字节数，buffer为缓冲区对象\n\n由于使用read()方法，会将文件内容读取buffer对象中，所以需要提前先准备一个buffer对象\n\n```js\nconst fs = require('fs')\nfs.open('1.txt','r',function(err,fd){\n  if(err){\n    console.log('文件打开失败')\n  }else{\n    const bf = Buffer.alloc(5)\n    fs.read(fd,bf,0,3,null,function(err,len,buffer){\n      console.log(err) // null\n      console.log(len) // 3\n      console.log(buffer) // <Buffer 61 61 61 00 00>\n    })\n  }\n});\n```\n#### 2-2 `fs.readSync(fd, buffer, offset, length, position)`\nfs.read() 的同步版本，返回 bytesRead 的数量\n\n```js\nconst fs = require('fs')\nconst fd = fs.openSync('1.txt','r')\nconst bf = Buffer.alloc(5)\nconst result = fs.readSync(fd,bf,0,3,null)\nconsole.log(result) // 3\n```\n### 3、写入文件\n\n#### 3-1 `fs.write(fd, buffer, offset, length[, position], callback)`\n\n参数如下\n\n* fd \\<Integer>  文件标识\n\n* buffer \\<String> | \\<Buffer> 要将buffer中的数据写入到文件中\n\n* offset \\<Integer> buffer对象中要写入的数据的起始位置\n\n* length \\<Integer> length是一个整数，指定要写入的字节数\n\n* position \\<Integer> 指定从文件开始写入数据的位置的偏移量。 如果 typeof position !== 'number'，则数据从当前位置写入\n\n* callback \\<Function> 回调有三个参数(err, written, buffer)，其中written指定从buffer写入了多少字节\n* \n**注意：多次对同一文件使用fs.write且不等待回调，是不安全的。对于这种情况，强烈推荐使用`fs.createWriteStream`。当我们要对打开的文件进行写操作的时候，打开文件的模式应该是读写模式**\n\n```js\nconst fs = require('fs')\nfs.open('1.txt','r+',function(err,fd){\n  if(err){\n    console.log('文件打开失败')\n  }else{\n    const bf = Buffer.from('test')\n    fs.write(fd,bf,0,3,null,function(err,len,buffer){\n      console.log(err) // null\n      console.log(len) // 3\n      console.log(buffer) // <Buffer 74 65 73 74>\n    })\n  }\n});\n```\n#### 3-2 `fs.write(fd, data[position[encoding]], callback)`\n\n该方法写入data到fd指定的文件。如果data不是一个Buffer实例，则该值将被强制转换为一个字符串\n\n不同于写入 buffer，该方法整个字符串必须被写入。不能指定子字符串，这是因为结果数据的字节偏移量可能与字符串的偏移量不同\n\n* fd  \\<Integer> 文件标识\n\n* data \\<String> | \\<Buffer> 要将string或buffer中的数据写入到文件中\n\n* position \\<Integer> 指向从文件开始写入数据的位置的偏移量。 如果 typeof position !== 'number'，则数据从当前位置写入\n\n* encoding \\<String> 期望的字符串编码\n\n* callback \\<Function> 回调有三个参数(err, written, str)，其中written指定从str写入了多少字节\n\n```js\nconst fs = require('fs');\nfs.open('1.txt','r+',function(err,fd){\n  if(err){\n    console.log('文件打开失败');\n  }else{\n    fs.write(fd,'12345',function(err,len,str){\n      console.log(err);//null\n      console.log(len);//5\n      console.log(str);//<Buffer 74 65 73 74>\n    })\n  }\n});\n```\n#### 3-3 `fs.writeSync()`\nfs.write() 的同步版本。返回写入的字节数\n\n```js\nconst fs = require('fs')\nconst fd = fs.openSync('1.txt','r+')\nconst bf = Buffer.alloc(5)\nconst result = fs.writeSync(fd,bf,0,3,null)\nconsole.log(result) // 3\n```\n### 4、关闭文件\n#### 4-1 `fs.close(fd, callback)`\n参数如下：\n\n* fd - 通过 fs.open() 方法返回的文件描述符。\n\n* callback - 回调函数，没有参数。\n\n```js\nconst fs = require('fs')\nfs.open('1.txt','r+',function(err,fd){\n  if(err){\n    console.log('文件打开失败')\n  }else{\n    fs.close(fd, function(err){\n      if (err){\n        console.log(err)\n      } \n      console.log(\"文件关闭成功\")\n    })\n  }\n})\n```\n#### 4-2 `fs.closeSync(fd)`\n同步版本，返回undefined\n\n```js\nconst fs = require('fs')\nconst fd = fs.openSync('1.txt','r+')\nfs.closeSync(fd)\n```\n## 三、File操作\n\n上一部分介绍的都是些底层的操作，接下来将介绍一些更便捷的文件操作。使用下列方法的时候，不需要再打开和关闭文件，直接操作即可\n\n### 1、写入文件\n#### 1-1 `fs.writeFile(file, data[, options], callback)`\n异步的将数据写入一个文件，如果文件不存在则新建，如果文件原先存在，会被替换\n\n参数如下\n* file - 文件名或文件描述符。\n\n* data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。\n\n* options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'\n\n* callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。\n\n#### 1-2 `fs.writeFileSync(file, data[, options])`\nfs.writeFile() 的同步版本。返回 undefined\n\n### 2、追加文件\n#### 2-1 `fs.appendFile(filename, data, [options], callback)`\n异步地追加数据到一个文件，如果文件不存在则创建文件。 data 可以是一个字符串或 buffer\n\n参数如下\n\n* file - 文件名或文件描述符。\n\n* data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。\n\n* options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'\n\n* callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。\n\n#### 2-2 `fs.appendFileSync(file, data[, options])`\n同步版本。返回undefined\n\n### 3、读取文件\n#### 3-1 `fs.readFile(file[, options], callback)`\n参数如下\n\n* file - 文件名或文件描述符\n\n* options - 该参数是一个对象，包含 {encoding, flag}。默认编码为null，即如果字符编码未指定，则返回原始的 buffer；flag默认为'r'\n\n* callback - 回调函数，回调有两个参数 (err, data)，其中data是文件的内容（buffer对象），err是错误信息参数，在写入失败时返回\n\n#### 3-2 `fs.readFileSync(file[, options])`\n同步版本。返回file的内容\n\n如果指定了encoding选项，则该函数返回一个字符串，否则返回一个buffer\n```js\nconst fs = require('fs')\nconst filename = '1.txt'\nconst result = fs.readFileSync(filename)\nconsole.log(result) //<Buffer 61 62 63 20 77 6f 72 6c 64 20 6c 61 6c 61 6c 61>\nconsole.log(result.toString()) 'abc world lalala'\n```\n### 4、删除文件\n#### 4-1 `fs.unlink(path, callback)`\n参数如下：\n\n* path - 文件路径。\n\n* callback - 回调函数，没有参数。 \n\n#### 4-2 `fs.unlinkSync(path)`\n同步版本，返回值为undefined\n\n### 5、重命名\n#### 5-1 `fs.rename(oldPath, newPath, callback)`\n参数如下：\n\n* oldPath \\<String> | \\<Buffer>\n\n* newPath \\<String> | \\<Buffer>\n\n* callback \\<Function> 回调只有一个可能的异常参数\n\n#### 5-2 `fs.renameSync(oldPath, newPath)`\n同步版本，返回undefined\n\n### 6、文件信息\n#### 6-1 `fs.stat(path, callback)`\n\nfs.stat()执行后，会将stats类的实例返回给其回调函数。可通过stats类中的提供方法判断文件的相关属性\n\n参数如下：\n\n* path - 文件路径。\n\n* callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象\n\n```js\nconst fs = require('fs')\nconst filename = 'a.txt'\nfs.stat(filename,function(err,stats){\n  console.log(err) // null\n/*\n{ dev: 223576,\n mode: 33206,\n nlink: 1,\n uid: 0,\n gid: 0,\n rdev: 0,\n blksize: undefined,\n ino: 7599824371527537,\n size: 0,\n blocks: undefined,\n atime: 2017-06-03T14:18:15.370Z,\n mtime: 2017-06-03T14:18:15.370Z,\n ctime: 2017-06-03T16:32:05.776Z,\n birthtime: 2017-06-03T14:18:15.370Z }\n */ \n  console.log(stats)\n})\n```\n**stats类中的方法有**\n\n* stats.isFile()  如果是文件返回 true，否则返回 false。\n\n* stats.isDirectory() 如果是目录返回 true，否则返回 false。\n\n* stats.isBlockDevice()   如果是块设备返回 true，否则返回 false。\n\n* stats.isCharacterDevice()   如果是字符设备返回 true，否则返回 false。\n\n* stats.isSymbolicLink()  如果是软链接返回 true，否则返回 false。\n\n* stats.isFIFO()  如果是FIFO，返回true，否则返回false。FIFO是UNIX中的一种特殊类型的命令管道。\n\n* stats.isSocket()    如果是 Socket 返回 true，否则返回 false。\n\n```js\nconst fs = require('fs')\nconst filename = 'a.txt'\nfs.stat(filename,function(err,stats){\n  console.log(stats.isFile()) // true\n})\n```\n#### 6-2 `fs.statSync(path)`\n同步版本，返回一个 fs.Stats 实例\n\n### 7、监听\n#### 7-1 `fs.watch(filename[, options][, listener])`\n\n该方法用于监视filename的变化，filename可以是一个文件或一个目录。返回的对象是一个fs.FSWatcher\n\n参数如下\n\n* filename \\<String> | \\<Buffer>\n\n* options \\<String> | \\<Object> 参数可选，如果options是一个字符串，则它指定了encoding。否则options应该以一个对象传入\n\n    * persistent \\<Boolean> 指明如果文件正在被监视，进程是否应该继续运行。默认为true\n\n    * recursive \\<Boolean> 指明是否全部子目录应该被监视，或只是当前目录。 适用于当一个目录被指定时，且只在支持的平台。默认为false\n\n    * encoding \\<String> 指定用于传给监听器的文件名的字符编码。默认为'utf8'\n\n* listener \\<Function> 回调函数有两个参数 (eventType, filename)。 eventType可以是'rename'或'change'，filename是触发事件的文件的名称\n\n回调中提供的 filename 参数仅在 Linux 和 Windows 系统上支持。 即使在支持的平台中，filename 也不能保证提供。 因此，不要以为 filename 参数总是在回调中提供，如果它是空的，需要有一定的后备逻辑\n\n```js\nfs.watch('somedir', (eventType, filename) => {\n console.log(`事件类型是: ${eventType}`)\n if (filename) {\n  console.log(`提供的文件名: ${filename}`)\n } else {\n  console.log('未提供文件名')\n }\n})\n```\n\n```js\nconst fs = require('fs')\nconst filename = '1.txt'\nfs.watch(filename,function(eventType, _filename){\n  console.log(eventType) // change\n  if(_filename){\n    console.log(_filename + '发生了改变') // '1.txt发生了改变'\n  }else{\n    console.log('...')\n  }\n   \n})\n```\n\n**注意: 当一个文件出现或消失在一个目录里时，'rename'也会被触发**\n\n## 四、fs目录操作\n### 1、创建\n#### 1-1 `fs.mkdir(path[, mode], callback)`\n参数如下：\n\n* path - 文件路径。\n\n* mode - 设置目录权限，默认为 0777。\n\n* callback - 回调函数，回调只有一个可能的异常参数\n\n#### 1-2 `fs.mkdirSync(path[, mode])`\n同步版本，返回undefined\n\n### 2、删除\n#### 2-1 `fs.rmdir(path, callback)`\n参数如下：\n\n* path - 文件路径。\n\n* callback - 回调函数，回调只有一个可能的异常参数\n\n#### 2-2 `fs.rmdirSync(path, callback)`\n同步版本，返回undefined\n\n### 3、读取\n#### 3-1 `fs.readdir(path[, options], callback)`\n参数如下：\n\n* path \\<String> | \\<Buffer>\n\n* options \\<String> | \\<Object> 可选的 options 参数用于传入回调的文件名，它可以是一个字符串并指定一个字符编码，或是一个对象且由一个 encoding 属性指定使用的字符编码。 如果 encoding 设为 'buffer'，则返回的文件名会被作为 Buffer 对象传入\n\n    * encoding \\<String> 默认 = 'utf8'\n\n* callback \\<Function> 回调有两个参数 (err, files)，其中 files 是目录中不包括 '.' 和 '..' 的文件名的数组\n\n```js\nvar fs = require('fs');\nfs.readdir('./',function(err,data){\n  console.log(err);//null\n/*\n[ '.csslintrc',\n '.jshintrc',\n 'a.txt',\n 'dist',\n 'Gruntfile.js',\n 'Gruntfile1.js',\n 'index.html',\n 'main.js',\n 'node_modules',\n 'package.json',\n 'src' ]\n */\n  console.log(data);\n})\n```\n\n```js\nvar fs = require('fs');\nfs.readdir('./',function(err,data){\n  data.forEach(function(item,index,arr){\n    fs.stat(item,function(err,stats){\n      if(stats.isFile()){\n        console.log('文件：' + item);\n      }\n      if(stats.isDirectory()){\n        console.log('目录：' + item);\n      }\n    });  \n  })\n})\n/*\n文件：.jshintrc\n文件：.csslintrc\n目录：dist\n文件：Gruntfile.js\n文件：index.html\n文件：Gruntfile1.js\n文件：main.js\n目录：node_modules\n文件：package.json\n文件：a.txt\n目录：src\n */\n```\n\n#### 3-2 `fs.readdirSync(path[, options], callback)`\n同步版本，返回一个不包括 '.' 和 '..' 的文件名的数组\n\n### 4、遍历目录\n遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录\n\n遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题\n\n```js\nfunction factorial(n) {\n  if (n === 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n```\n上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1\n\n目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是A > B > D > E > C > F\n\n```\n          A\n\n         / \\\n\n        B   C\n\n       / \\   \\\n\n      D   E   F\n```\n\n了解了必要的算法后，我们可以简单地实现以下目录遍历函数\n\n```js\nfunction travel(dir, callback) {\n  fs.readdirSync(dir).forEach(function (file) {\n    var pathname = path.join(dir, file);\n    if (fs.statSync(pathname).isDirectory()) {\n      travel(pathname, callback);\n    } else {\n      callback(pathname);\n    }\n  });\n}\n```\n\n可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录\n\n```\n  - /home/user/\n    - foo/\n        x.js\n    - bar/\n        y.js\n    z.css\n```\n\n使用以下代码遍历该目录时，得到的输入如下\n\n```js\ntravel('/home/user', function (pathname) {\n  console.log(pathname);\n});\n------------------------\n/home/user/foo/x.js\n/home/user/bar/y.js\n/home/user/z.css\n```\n\n如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下\n\n```js\nfunction travel(dir, callback, finish) {\n  fs.readdir(dir, function (err, files) {\n    (function next(i) {\n      if (i < files.length) {\n        var pathname = path.join(dir, files[i]);\n        fs.stat(pathname, function (err, stats) {\n          if (stats.isDirectory()) {\n            travel(pathname, callback, function () {\n              next(i + 1);\n            });\n          } else {\n            callback(pathname, function () {\n              next(i + 1);\n            });\n          }\n        });\n      } else {\n        finish && finish();\n      }\n    }(0));\n  });\n```","tagIds":"13,17,11","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":666,"type":1,"groupTimestamp":"1699548014798","cover":"https://florelierogier.files.wordpress.com/2015/06/love-banana-minions.jpg?w=1200","categoryId":2,"created_at":"2023-11-09T16:40:28.000Z","updated_at":"2023-11-10T14:18:41.000Z","tagList":[{"id":11,"name":"JavaScript"},{"id":13,"name":"NodeJS"},{"id":17,"name":"Koa"}],"createDate":"2023-11-10"}