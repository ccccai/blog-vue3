{"id":25,"title":"仿照git马赛克墙用JS&SVG实现的数据可视化热力图工具","subTitle":"仿照git马赛克墙实现的JS原生热力图数据可视化工具，支持自定义日期、支持自定义横纵坐标等","link":null,"description":"","content":"先上效果图\n\n- 日历型热点图\n\n![日历型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cedc5bcb49921b~tplv-t2oaga2asx-image.image)\n\n- 自定义型热点图，可以自己定义横纵坐标\n\n![自定义型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cedc6317f11818~tplv-t2oaga2asx-image.image)\n\n> 说一说实现的心理历程，本来想像码云那个一样用div来实现的，但是脑子灵光一闪，我怎么不用canvas试一试呢，之前没什么机会接触过，刚好来练练手。\n于是就实现了一波：\n\n``` javascript\n  this.init = (dom) => {\n    var section = this.option.size + this.option.gap\n    dom.width = section * this.option.xAxis.length\n    dom.height = section * this.option.yAxis.length\n    // 调用canvas对象的getContext()方法，c变量就包含了指向2d渲染环境的引用\n    var context = dom.getContext('2d')\n    var levelGap = (this.option.max - this.option.min) / 4\n    this.option.data.forEach((item) => {\n      // [x, y, value]\n      var differ = this.option.max - item[2]\n      switch(true) {\n        case (item[2] >= this.option.max) :\n          color = 'rgb(25, 97, 39)'\n          break\n        case (differ < levelGap) :\n          color = 'rgb(35, 154, 59)'\n          break\n        case (differ < levelGap * 2) :\n          color = 'rgb(123, 201, 111)'\n          break\n        case (differ < levelGap * 3) :\n          color = 'rgb(198, 228, 139)'\n          break\n        default:\n          color = 'rgb(235, 237, 240)'\n      }\n      context.fillStyle = color\n      context.fillRect(item[0] * section, item[1] * section, this.option.size, this.option.size)\n    })\n  }\n```\n> 写到一半，发现不行啊，人家canvas是一整张画布，但是我是需要一个个小方格可以实现鼠标悬浮显示详细信息的呀，不妥不妥。于是我又想到了svg这个好家伙，F12看了下git，正好人家也是使用svg实现的。\n\n```!\n实现过程不复杂，就是比较绕，感兴趣怎么实现的小伙伴，我把项目地址贴出来了噢。如果我的组件是你需要用到的，那欢迎使用哈哈哈哈~~，下面说一说怎么使用，还有一些思考\n```\n\n### 一、项目地址\n\n[仿照git马赛克墙实现了个JS原生小工具，支持自定义日期、支持自定义横纵坐标](https://github.com/ccccai/heat-map)\n\n### 二、使用方法\n\n使用起来很简单，只要引入css文件和js文件即可\n\n#### 2.1 引入css和js\n引入css：\n```html\n<link rel=\"stylesheet\" href=\"./heatMap.css\" />\n```\n\n引入js：\n```html\n<script src=\"./heatMap.js\"></script>\n```\n\n#### 2.2 初始化heatMap\n```javascript\n<script>\n  var heatMap = new HeatMapDate()\n  var option = {\n    gap: 6,\n    type: 'custom',\n    xAxis: ['11', '22', '33', '44'],\n    yAxis: ['aa', 'bb'],\n    data: [\n      [0, 0, 0],\n      // ...\n      [3, 1, 1]\n    ],\n    min: 0,\n    max: 6,\n    tip: {\n      show: true,\n      formatter: '第{y}月的第{x}天有{b}个提交'\n    }\n  }\n  heatMap.setOption(option)\n  heatMap.init(document.getElementById('mySvg'))\n<\\script>\n```\n\n### 三、配置参数说明\n#### 3.1 初始化参数，需传入配置参数option：\n```js\nheatMap.setOption(option)\n```\n\n#### 3.2 初始化热力图，需传入需要挂载的dom节点：\n```js\nheatMap.init(dom)\n```\n\n#### 3.3 option参数说明\n\n| 参数 | 说明 | 类型 | 可选值 | 默认值 |\n| ------ | ------ | ------ | ------ | ------ |\n| type | 热力图类型,分两种，date-日历型和custom-自定义型 | String | date/custom | date |\n| xAxis | 横坐标的label,当type为custom类型时需要传递该参数 | Array | - | - |\n| yAxis | 纵坐标的label,当type为custom类型时需要传递该参数 | Array | - | - |\n| gap | 方格之间的间隔 | Number | - | 3 |\n| data | 数据,如果type是date,那data是Object类型,格式{yyyy-MM-dd: value ...};如果type是custom,那data是Array类型,格式[[x,y,value]...] | Object/Array | - | - |\n| dateStart | 当type为date类型时起作用，表示起始日期，日期格式：yyyy-MM-dd | String | - | 去年的今天 |\n| rect | 方格的相关属性 | Object | - | - |\n| dateEnd | 当type为date类型时起作用，表示结束日期，日期格式：yyyy-MM-dd | String | - | 今天 |\n| min | 分级的最低值，默认总共五个等级 | Number | - | 0 |\n| max | 分级的最高值，默认总共五个等级 | Number | - | data里头的值的最大值 |\n| tip | 方格顶部鼠标悬浮小气泡的相关属性 | Object | - | - |\n| tip.show | 鼠标悬浮是否显示小气泡 | Boolean | true/false | true |\n| tip.formatter | 小气泡的文本内容。type为date的时候{a}表示日期，{b}表示数值；type为custom的时候{x}表示x轴对应的值，{y}对应y轴的值，{b}表示数值；如果在替换字符串前加反斜杠(例如/{b})，则不会替换该字符串 | String | - | - |\n| rect | 方格的相关属性 | Object | - | - |\n| rect.stroke | 方格边框的相关属性 | Object | - | - |\n| rect.stroke.show | 是否显示方格边框 | Boolean | true/false | false |\n| rect.stroke.background | 方格边框颜色 | String | - | #333333 |\n| rect.stroke.opacity | 方格边框透明度 | Float | 0～1 | 0.6 |\n| rect.colourMatching | 方格配色方案，可以自定义（custom）也可以使用现有的配色方案 | String | custom/green/pink/blue/orange/gray | green |\n| rect.stroke.backgroundArr | 当type为custom类型时起作用，方格配色方案具体颜色，多少个颜色就表示多少个等级，等级由重到轻，第一个颜色表示等级最重 | Array | - | - |\n\n### 四、总结与思考\n\n说一说实现过程中的痛点：\n1. 日历型和自定义型的数据结构必须不同。逻辑得分开写。\n\n日历型我知道横轴就是月份，纵轴就是星期，所以我new新的热力图的时候，传的数据里头只要有日期和值就行。但自定义就不一样了，自定义的横纵坐标都是后来定义的，所以为了知道具体的哪个小方格的值，传的数据里头必须像```[x, y, value]```这样的结构。\n\n2. 日期的轮询\n\n日历型热力图默认是当前时间往前推一年这样一个时间跨度，所以我必须轮询出这一年里的所有日期，再拼装组合起来。后期考虑到了灵活性，所以这个时间跨度也是可以自定义的。\n\n3. 小方格的size的确定。\n\n小方格的size关乎到左边区域的大小。总的来说就是当前容器的宽度减去左边区域大小，再除以列数，写的时候的逻辑比较绕，跟写高数题似的，想起了当年被支配的恐惧。。\n\n4. 顶部悬浮气泡的位置确定。\n\n顶部悬浮气泡实际上我只定义了一个容器，每次调用的时候，改变定位和文字内容。\n\n5. 配色自定义\n\n配色这一块，有多少个配色就有多少个等级。我不希望把颜色定死，所以自己组合定义了五种配色方案：green、pink、blue、orange、gray。考虑到有改变等级和配色的需要，配置项可以自定义。\n\n> 总的来说，实现的思路并不难，就是实现的过程比较蛋疼。后期我打算增加一些自定义功能，然后做成根据屏幕大小来动态改变布局。有想法将它封装成npm工具，也算是我的第一个正儿八经开源小工具啦，源码我已经贴出了来，有需要一起学习的小伙伴自行clone～～笔芯\n\n### 五、主要代码heatMap.js\n这就是我实现这个小工具的最核心代码：\n```javascript\n/**\n * 对Date的扩展，将 Date 转化为指定格式的String\n * 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，\n * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)\n * 例子：\n * (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423\n * (new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==> 2006-7-2 8:9:4.18\n *  @param fmt 日期格式\n */\nDate.prototype.format = function (fmt) {\n  var o = {\n      \"M+\": this.getMonth() + 1, //月份\n      \"d+\": this.getDate(), //日\n      \"h+\": this.getHours(), //小时\n      \"m+\": this.getMinutes(), //分\n      \"s+\": this.getSeconds(), //秒\n      \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度\n      \"S\": this.getMilliseconds() //毫秒\n  };\n  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n  for (var k in o)\n      if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n  return fmt;\n}\n\n/**\n * 字符串转换为日期对象\n * @param dateStr Date 格式为yyyy-MM-dd HH:mm:ss，必须按年月日时分秒的顺序，中间分隔符不限制\n */\nDate.prototype.strToDate = function (dateStr) {\n  var data = dateStr\n  var reCat = /(\\d{1,4})/gm\n  var t = data.match(reCat)\n  t[1] = t[1] - 1\n  eval('var d = new Date(' + t.join(',') + ')')\n  return d\n}\n\n/**\n * 获取日期列表，不传参默认当前时间为截止日期，去年的今天为起始日期\n * @param dateStart 起始日期 格式为yyyy-MM-dd，必须按年月日的顺序，中间分隔符不限制\n * @param dateEnd 截止日期 格式为yyyy-MM-dd，必须按年月日的顺序，中间分隔符不限制\n */\nDate.prototype.getDateList = function (dateStart, dateEnd) {\n  try {\n    var date, diff, list = {}\n    // 缺一不可，缺任何一个都采取默认时间\n    if (!dateStart || !dateEnd) {\n      // 当前时间\n      date = new Date()\n      // 当前时间往前推一年\n      date.setFullYear(date.getFullYear() - 1)\n      // 如果去年的今天不是星期天的话，补充天数直到起始日期是星期天为止\n      while (date.getDay() > 0) {\n        date.setDate(date.getDate() - 1)\n      }\n      // 计算相差的天数\n      diff = parseInt((new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24))\n    } else {\n      // 转换为日期对象\n      var start = this.strToDate(dateStart)\n      var end = this.strToDate(dateEnd)\n      // 补充天数直到起始日期是星期天为止\n      while (start.getDay() > 0) {\n        start.setDate(start.getDate() - 1)\n      }\n      // 计算相差的天数\n      diff = parseInt((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))\n      date = start\n    }\n    // 实际上连最后一天也要算上，所以diff加2\n    for (i = 1; i < diff + 2; i++) {\n      list[date.format(\"yyyy-MM-dd\")] = date.getDay()\n      date.setDate(date.getDate() + 1)\n    }\n    return list\n  } catch(e) {\n    return {}\n  }\n}\n\nvar weekMap = ['周日', '周一', '周二', '周三', '周四', '周五', '周六']\nvar monthMap = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']\nvar colorMap = {\n  'blue': ['#003C9D', '#409EFF', '#87CEFA', '#E0FFFF', '#EBEDF0'],\n  'pink': ['#990099', '#CC00CC', '#FF88C2', '#FFB7DD', '#EBEDF0'],\n  'green': ['#196127', '#239A3B', '#7BC96F', '#C6E48B', '#EBEDF0'],\n  'orange': ['#A42D00', '#CC6600', '#EE7700', '#FFAA33', '#EBEDF0'],\n  'gray': ['#303133', '#444444', '#808080', '#C0C0C0', '#EBEDF0']\n}\n\n// 合并两个object，以mainObj为基准\nfunction matchObj(mainObj, obj) {\n  var resultObj = {}\n  for (var key in mainObj) {\n    if (!obj.hasOwnProperty(key)) {\n      resultObj[key] = mainObj[key]\n    } else if (Object.prototype.toString.call(mainObj[key]) === '[Object Object]' && key !== 'data') {\n      resultObj[key] = matchObj(mainObj[key], obj[key])\n    } else {\n      resultObj[key] = obj[key]\n    }\n  }\n  return resultObj\n}\n\nfunction HeatMapDate() {\n  this.option = {\n    type: 'date', // 类型：date-日历型，custom-自定义型\n    xAxis: [], // 横坐标的label，type=custom起作用\n    yAxis: [], // 纵坐标的label，type=custom起作用\n    gap: 3, // 方格之间的间隔\n    /* 数据\n     * 如果type是date。那data是Object类型，格式是{ 'yyyy-MM-dd' : value }\n     * 如果type是custom。那data是Array类型，格式是[[x, y, value], ..., [x, y, value]]\n     */\n    data: {},\n    rect: {\n      stroke: {\n        show: false,\n        background: '#333', // 正方形的边框颜色\n        opacity: 0.6 // 正方形的边框透明度\n      },\n      colourMatching: '', //配色方案，有custom-自定义和reen、pink、blue、orange、gray五种渐变色\n      backgroundArr: [] // 自定义配色方案，程度由重到轻\n    },\n    dateStart: '',\n    dateEnd: '',\n    min: 0, // 分级最低值，总共五个等级，不传默认值是0\n    max: 0, // 分级最高值，总共五个等级，不传默认值是\n    tip: { // 顶部鼠标悬浮小气泡\n      show: true, // 是否展示\n      /** 文本内容\n       * type为date的时候{a}表示日期，{b}表示数值\n       * type为custom的时候表示{x}x轴对应的值，{y}y轴对应的值，{b}表示数值\n       * 如果在替换字符串前加反斜杠(例如/{b})，则不会替换该字符串\n       */\n      formatter: ''\n    }\n  }\n\n  // 初始化参数，没传的就使用默认值\n  this.setOption = (obj) => {\n    this.option = matchObj(this.option, obj)\n    if (!this.option.max) {\n      this.option.max = Object.values(obj.data).sort(function(a, b) {\n        return b - a\n      })[0] || 0\n    }\n  }\n\n  this.init = (dom) => {\n    // 初始化dom的样式\n    dom.setAttribute('style', 'width:100%;height:100%;position:relative;')\n    // 获取父级dom的宽度\n    var parentWidth = dom.offsetWidth\n    // 通过createElementNS创建svg元素并设置属性\n    var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')\n    svg.setAttribute('version', '1.1')\n    svg.setAttribute('class', 'svg-container')\n    dom.appendChild(svg) // 挂载元素。SVG元素添加到页面内显示\n\n    // 显示顶部提示小气泡\n    if (this.option.tip.show) {\n      // 创建tip容器并设置属性\n      var tip = document.createElement('div')\n      tip.setAttribute('class', 'svg-tip svg-tip-one-line')\n      var title = document.createElement('strong')\n      tip.appendChild(title) // 挂载到父节点上\n      dom.appendChild(tip) // 挂载元素。挂载顶部提示气泡\n    }\n\n    // 创建svg的group元素并设置属性\n    var group = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n    var translateX = 20 // 横轴方向的偏移值\n    var translateY = 40 // 纵轴方向的偏移值\n    group.setAttribute('transform', 'translate(' + translateX + ',' + translateY + ')')\n    svg.appendChild(group) // 挂载到父节点上\n\n    var maxYLabelFontSize = 12\n    var labelPadding = 10\n    var maxStrLength = 0\n\n    if (this.option.type === 'date') {\n      // 获取全部天数列表\n      var dateList = (new Date()).getDateList(this.option.dateStart, this.option.dateEnd)\n      var columnCount = Math.ceil(Object.keys(dateList).length / 7)\n      var size = Math.floor((parentWidth - translateX / 2 - maxYLabelFontSize * 2 - labelPadding - this.option.gap * columnCount) / columnCount)\n      var section = size + this.option.gap\n\n      // 纵轴的label值，这里是星期值\n      for (var w = 0; w < 7; w++) {\n        //创建矩形元素并设置属性\n        var yText = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n        yText.style.fontSize = section * 0.7 > maxYLabelFontSize ? maxYLabelFontSize : section * 0.7 // 字体大小响应，最大是12px\n        yText.setAttribute('dx', -labelPadding)\n        yText.setAttribute('dy', w * section + size / 2 + 4)\n        yText.setAttribute('class', 'wday')\n        yText.innerHTML = weekMap[w]\n        group.appendChild(yText)\n        if (maxStrLength < yText.getBBox().width) {\n          maxStrLength = yText.getBBox().width\n        }\n      }\n\n      var index = 0 // 天数列表索引\n      var column = 0 // 分组索引，完整的一周为一组\n      for (var dateKey in dateList) {\n        // 完整的一周为一组\n        if (index === 0 || index % 7 === 0) {\n          // 创建svg的group元素并设置属性，一周为一组\n          var xGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n          // 设置偏移值\n          xGroup.setAttribute('transform', 'translate(' + (column * section + maxStrLength) + ', 0)')\n          group.appendChild(xGroup) // 挂载到父节点\n          column++ // 递增组数索引\n\n          // 判断在哪个分组的上方增加横轴的label值，在这里是月份\n          if (index > 0) {\n            var startMonth = dateKey.split('-')[1]\n            var preStartMonth = Object.keys(dateList)[index - 7].split('-')[1]\n            \n            if (Math.abs(Number(startMonth) - Number(preStartMonth)) > 0) {\n              //创建text元素并设置属性\n              var fontSize = section * 0.8 > maxYLabelFontSize ? maxYLabelFontSize : section * 0.8 // 字体大小响应，最大是14px\n              var xText = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n              xText.style.fontSize = fontSize\n              xText.setAttribute('x', column * section)\n              xText.setAttribute('y', -labelPadding)\n              xText.setAttribute('class', 'month')\n              xText.innerHTML = monthMap[Number(startMonth) - 1]\n              group.appendChild(xText)\n            }\n          }\n        }\n        if(this.option.data.hasOwnProperty(dateKey)) {\n          // 开始画正方形啦~创建矩形元素并设置属性\n          var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n          rect.setAttribute('x', 0)\n          rect.setAttribute('y', dateList[dateKey] * section)\n          rect.setAttribute('id', dateKey) // 设置日期为id值\n          rect.setAttribute('week', dateList[dateKey]) // 设置星期几属性\n          rect.setAttribute('column', column) // 设置分组的组索引属性\n          rect.setAttribute('width', size)\n          rect.setAttribute('height', size)\n\n          color = '#fff' // 默认颜色是白色，就是啥也没有时候的颜色，以你的背景色为准 \n          var colorSelect = ''\n          // 选择的颜色系列\n          if (this.option.rect.colourMatching === 'custom') {\n            colorSelect = this.option.rect.backgroundArr\n          } else {\n            colorSelect = colorMap[this.option.rect.colourMatching]\n          }\n          // 默认绿色为基本配色方案\n          colorSelect = colorSelect ? colorSelect : colorMap['green']\n          // 分为五个等级，小于最小值最低等级，大于最大值最高等级。中间还应该有三个等级（可自定义）\n          var levelGap = (this.option.max - this.option.min) / (colorSelect.length - 2)\n          if (this.option.data.hasOwnProperty(dateKey)) {\n            var differ = this.option.max - this.option.data[dateKey]\n            // 小正方形的颜色决定于他的值处在哪个level里头\n            switch(true) {\n              case (this.option.data[dateKey] >= this.option.max) :\n                color = colorSelect[0]\n                break\n              case (differ < levelGap) :\n                color = colorSelect[1]\n                break\n              case (differ < levelGap * 2) :\n                color = colorSelect[2]\n                break\n              case (differ < levelGap * 3) :\n                color = colorSelect[3]\n                break\n              default:\n                color = colorSelect[4]\n            }\n            // 设置小矩形的颜色\n            rect.setAttribute('style', 'fill:' + color)\n          \n            // 显示顶部提示小气泡\n            if (this.option.tip.show) {\n              //矩形元素绑定鼠标事件实现动态效果\n              // 鼠标移入\n              rect.onmouseover = (e) => {\n                if (this.option.rect.stroke.show) {\n                  e.srcElement.setAttribute('stroke-width', 1)\n                  e.srcElement.setAttribute('stroke', this.option.rect.stroke.background)\n                  e.srcElement.setAttribute('stroke-opacity', this.option.rect.stroke.opacity)\n                }\n\n\n                // 提示小气泡的文本内容,默认==>日期：值\n                if (this.option.tip.formatter) {\n                  var tipText = this.option.tip.formatter.replace(/(?<!\\/){a}/g, e.target.id).replace(/(?<!\\/){b}/g, this.option.data[e.target.id])\n                  tip.innerHTML = tipText\n                } else {\n                  tip.innerHTML = e.target.id + '：' + this.option.data[e.target.id]\n                }\n                tip.style.display = 'block'\n                tip.style.top = (e.target.attributes.week.value * section + dom.querySelector('.svg-tip').offsetHeight / 2 - translateY / 2 - labelPadding) + 'px'\n                tip.style.left = ((e.target.attributes.column.value - 1) * section + size / 2 + translateX / 2 + maxStrLength + labelPadding - dom.querySelector('.svg-tip').offsetWidth / 2) + 'px'\n              }\n              // 鼠标移出\n              rect.onmouseout = (e) => {\n                if (this.option.rect.stroke.show) {\n                  e.srcElement.setAttribute('stroke-width', 0)\n                }\n                tip.style.display = 'none'\n              }\n            }\n          }\n          xGroup.appendChild(rect) //挂载矩形元素添加到小分组元素内\n        }\n        index++\n      }\n\n      // 设置svg元素的宽高\n      svg.style.width = Math.ceil(section * columnCount + translateX + maxStrLength + labelPadding)\n      svg.style.height = section * 7 + translateY\n    }\n\n    if (this.option.type === 'custom') {\n      var size = parseInt(parentWidth / this.option.xAxis.length) - this.option.gap * this.option.xAxis.length \n      var section = size + this.option.gap\n      var fontSize = section * 0.7 > maxYLabelFontSize ? maxYLabelFontSize : section * 0.7 // 字体大小响应，最大是12px\n\n      this.option.xAxis.forEach((xItem,xIndex) => {\n        var xGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n        group.appendChild(xGroup)\n\n        this.option.yAxis.forEach((yItem,yIndex) => {\n          if (xIndex === 0) {\n            //创建矩形元素并设置属性\n            var yText = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n            yText.style.fontSize = fontSize\n            yText.setAttribute('dx', -labelPadding)\n            yText.setAttribute('dy', yIndex * section + size / 2 + 4)\n            yText.setAttribute('class', 'wday')\n            yText.innerHTML = yItem\n            group.appendChild(yText)\n            if (maxStrLength < yText.getBBox().width) {\n              maxStrLength = yText.getBBox().width\n            }\n          }\n\n          this.option.data.some((elem, i) => {\n            if (elem[0] === xIndex && elem[1] === yIndex) {\n              color = 'rgb(255, 255, 255)' // 默认颜色是白色，就是啥也没有时候的颜色，以你的背景色为准 \n              var colorSelect = ''\n              // 选择的颜色系列\n              if (this.option.rect.colourMatching === 'custom') {\n                colorSelect = this.option.rect.backgroundArr\n              } else {\n                colorSelect = colorMap[this.option.rect.colourMatching]\n              }\n              // 默认绿色为基本配色方案\n              colorSelect = colorSelect ? colorSelect : colorMap['green']\n              // 分为五个等级，小于最小值最低等级，大于最大值最高等级。中间还应该有三个等级（可自定义）\n              var levelGap = (this.option.max - this.option.min) / (colorSelect.length - 2)\n              var differ = this.option.max - elem[2]\n              // 小正方形的颜色决定于他的值处在哪个level里头\n              switch(true) {\n                case (elem[2] >= this.option.max) :\n                  color = colorSelect[0]\n                  break\n                case (differ < levelGap) :\n                  color = colorSelect[1]\n                  break\n                case (differ < levelGap * 2) :\n                  color = colorSelect[2]\n                  break\n                case (differ < levelGap * 3) :\n                  color = colorSelect[3]\n                  break\n                default:\n                  color = colorSelect[4]\n              }\n\n              //创建矩形元素并设置属性\n              var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n              rect.setAttribute('x', 0)\n              rect.setAttribute('y', elem[1] * section)\n              rect.setAttribute('id', elem[0] + '_' + elem[1]) // 设置日期为id值\n              rect.setAttribute('row', yIndex)\n              rect.setAttribute('column', xIndex)\n              rect.setAttribute('width', size)\n              rect.setAttribute('height', size)\n              rect.setAttribute('style', 'fill:' + color)\n\n              // 显示顶部提示小气泡\n              if (this.option.tip.show) {\n                //矩形元素绑定鼠标事件实现动态效果\n                // 鼠标移入\n                rect.onmouseover = (e) => {\n                  if (this.option.rect.stroke.show) {\n                    e.srcElement.setAttribute('stroke-width', 1)\n                    e.srcElement.setAttribute('stroke', this.option.rect.stroke.background)\n                    e.srcElement.setAttribute('stroke-opacity', this.option.rect.stroke.opacity)\n                  }\n\n                  var xyArr = e.target.id.split('_')\n                  // 提示小气泡的文本内容,默认==>x_y：值\n                  if (this.option.tip.formatter) {\n                    var tipText = this.option.tip.formatter.replace(/(?<!\\/){x}/g, this.option.xAxis[xyArr[0]]).replace(/(?<!\\/){y}/g, this.option.yAxis[xyArr[1]]).replace(/(?<!\\/){b}/g, elem[2])\n                    tip.innerHTML = tipText\n                  } else {\n                    tip.innerHTML = e.target.id + '：' + elem[2]\n                  }\n                  tip.style.display = 'block'\n                  tip.style.top = (e.target.attributes.row.value * section + dom.querySelector('.svg-tip').offsetHeight / 2 - translateY / 2 - labelPadding) + 'px'\n                  tip.style.left = (e.target.attributes.column.value * section + size / 2 + translateX / 2 + maxStrLength + labelPadding - dom.querySelector('.svg-tip').offsetWidth / 2) + 'px'\n                }\n                // 鼠标移出\n                rect.onmouseout = (e) => {\n                  if (this.option.rect.stroke.show) {\n                    e.srcElement.setAttribute('stroke-width', 0)\n                  }\n                  tip.style.display = 'none'\n                }\n              }\n              //将矩形元素添加到SVG元素内\n              xGroup.appendChild(rect)\n              return true\n            } else {\n              return false\n            }\n          })\n        })\n\n        xGroup.setAttribute('transform', 'translate(' + (xIndex * section + maxStrLength) + ', 0)')\n        \n        //创建text元素并设置属性\n        var xText = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n        xText.style.fontSize = fontSize\n        xText.setAttribute('x', xIndex * section + maxStrLength)\n        xText.setAttribute('y', -labelPadding)\n        xText.setAttribute('class', 'month')\n        xText.innerHTML = xItem\n        group.appendChild(xText)\n        xText.setAttribute('textLength', size < xText.getBBox().width ? size : xText.getBBox().width)\n      })\n      // 设置svg元素的宽高\n      svg.style.width = section * this.option.xAxis.length + translateX / 2 + labelPadding + maxStrLength\n      svg.style.height = section * this.option.yAxis.length + translateY\n    }\n  }\n}\n```\n","tagIds":"4,11,10","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":67,"type":1,"groupTimestamp":"1557868875843","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/2/16cede10db34c836~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:22:31.000Z","updated_at":"2023-11-23T08:58:08.000Z","tagList":[{"id":4,"name":"CSS"},{"id":10,"name":"HTML"},{"id":11,"name":"JavaScript"}],"createDate":"2019-05-15"}