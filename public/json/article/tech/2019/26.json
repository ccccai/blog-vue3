{"id":26,"title":"打造vuecli3+element后台管理系统（四）讲讲让本秃头星人头大的动态菜单、页面权限和角色赋权在后台系统中的实现","subTitle":"","link":null,"description":"许多时候咱们的做的后台系统，面向的人群可能是五花八门的，后台系统中展示的数据大部分是公司相关的运营数据，所以呢必须严格控制用户的权限。用户是否有权访问这个菜单、用户访问这个菜单之后，是否有权进行增删改查，这都是身为一个合格滴后台系统所要具备的功能（敲黑板）。","content":"### 一、定义权限接口返回的数据的json结构\n权限模块可以说是后台系统的重中之重，它可简单，可复杂，具体看产品大大如何定义。\n\n平时后台兄弟的接口返回的数据体结构，都是他说了算，他怎么给滴，咱就怎么渲染。但是其实这样是很被动的，为了提高我们的开发效率，我们要把精力更多的放在页面上而不是把精力放在绞尽脑汁想怎么把后台给的数据遍历转化为我想要的结构，数据的二次处理有时正是我们被吐槽开发慢的原因之一呀！（摔杯\n\n所以适当的和后台大兄弟沟通一下返回的数据体的结构，能让后台大兄弟处理的，就让他处理，相信我，其实开口沟通没那么难。\n\n扯远了，话又说回来，因为权限模块的特殊性，所以这一块返回的结构是怎么样的，我们需要给后台大兄弟提供大致的维度结构。\n\n我的项目里是这样去定义这个结构的：\n> 这里是简化了的结构，保留了核心字段，在这个项目里菜单是二级结构的，一级是菜单大类，children表示底下的二级页面，二级下面就是页面的路由名称和该用户在这个菜单下面拥有的权限，这里定义了增add、删delete、改edit、查check四个\n```\n[\n    {\n        name: 'Table',\n        children: [\n            {\n                name: 'TableDemo',\n                auth: {\n                    add: true,\n                    check: true,\n                    delete: true,\n                    edit: true\n                }\n            }\n        ]\n    }\n]\n```\n\n### 二、定义需要动态加载的路由，定义mock接口\n\n假设现在有一个路由是需要权限才能访问的，我们在router/modules下定义一个table.js文件，这下面的demo页是需要后台返回了相关菜单，用户才能有权访问。\n``` javascript\n// table.js\nconst table = {\n  path: 'table',\n  component: () => import('@/layout'),\n  redirect: '/table/demo',\n  name: 'Table',\n  meta: {\n    title: 'parentTitle',\n    icon: 'table'\n  },\n  children: [\n    {\n      path: '/table/demo',\n      name: 'TableDemo',\n      component: resolve => void require(['@/views/table/demo'], resolve),\n      meta: {\n        title: 'tableDemo'\n      }\n    },\n    {\n      path: '/table/demoTest',\n      name: 'DemoTest',\n      component: resolve => void require(['@/views/table/demoTest'], resolve),\n      meta: {\n        title: 'demoTest'\n      }\n    }\n  ]\n}\n\nexport default table\n\n```\n\nmock接口数据，这里我们只给用户了第一个子菜单，第二个不给看\n``` javascript\n// mock/index.js\nconst permissionData = () => {\n  result.data = [\n    {\n      name: 'Table',\n      children: [\n        {\n          name: 'TableDemo',\n          auth: {\n            add: true,\n            check: true,\n            delete: true,\n            edit: true\n          }\n        }\n      ]\n    }\n  ]\n  return result\n}\n\nMock.mock('/apiReplace/permission', 'post', permissionData)\n```\n接口数据我们已经mock中定义了，可以着手写如何获取动态路由的逻辑了\n\n### 三、定义处理权限相关逻辑的vuex仓库文件。\n在store/modules目录下新建permission.js，我们需要在vuex中定义路由和权限的逻辑，包括初始化动态路由、重置路由等。\n\n```javascript\n// permission.js\n\n/** 这些在上一篇路由模块的定义里有讲到，或者是小伙伴可以去项目里头看看router文件，我这里不贴router文件的代码了~~\n * constantRoutes 常规路由，不需要权限即可访问\n * asyncRoutes 需要访问权限的路由\n * notFoundRoutes 404路由\n * resetRouter 重置路由的方法\n */\nimport { asyncRoutes, constantRoutes, notFoundRoutes, resetRouter } from '@/router'\nimport API from '@/assets/http/apiUrl'\nimport Request from '@/assets/http'\n\nconst permission = {\n  state: {\n    routes: [],\n    addRoutes: [] // 异步加载的路由\n  },\n\n  mutations: {\n    SET_ROUTES: (state, routes) => {\n      state.addRoutes = routes\n      state.routes = constantRoutes.concat(routes)\n    }\n  },\n\n  actions: {\n    // 获取动态路由\n    GenerateRoutes({ commit }, isSuperAdmin) {\n      resetRouter() // 先初始化路由\n      return new Promise((resolve, reject) => {\n        // 如果是超级管理员,挂载全部路由全部权限\n        if (isSuperAdmin) {\n          // 重定向404的匹配规则需要在整个完整路由定义的最后面，否则刷新会出错。\n          const accessedRoutes = [...asyncRoutes, ...notFoundRoutes]\n          accessedRoutes.forEach(item => {\n            if (item.children) {\n              // 超级管理员赋全部权限\n              item.children.forEach(elem => {\n                elem.meta = {\n                  ...elem.meta,\n                  check: true,\n                  delete: true,\n                  add: true,\n                  edit: true\n                }\n              })\n            }\n          })\n          commit('SET_ROUTES', accessedRoutes)\n          resolve(accessedRoutes)\n        } else {\n          Request.httpRequest({\n            method: 'post',\n            url: API.GetPermissionData,\n            noLoading: true,\n            params: {},\n            success: (data) => {\n              console.log(data)\n              let accessedRoutes = []\n              // 匹配前端路由和后台返回的菜单\n              accessedRoutes = filterAsyncRoutes(asyncRoutes, data)\n              // 重定向404的匹配规则需要在整个完整路由定义的最后面，否则刷新会出错。\n              accessedRoutes.push(...notFoundRoutes)\n              commit('SET_ROUTES', accessedRoutes)\n              resolve(accessedRoutes)\n            },\n            error: res => {\n              reject(res)\n            }\n          })\n        }\n      })\n    }\n  }\n}\n\n/**\n * Filter asynchronous routing tables by recursion\n * 匹配后台返回的菜单信息和前端定义的路由\n * @param routes 前端定义好的异步路由\n * @param menus 后台返回的菜单\n */\nexport function filterAsyncRoutes(routes = [], menus = []) {\n  const res = []\n\n  routes.forEach(route => {\n    // 复制一遍路由，这样改变tmp的同时路由不会受影响\n    const tmp = {\n      ...route\n    }\n\n    // 是否匹配到了\n    if (hasPermission(menus, tmp)) { // 有符合的匹配项\n      // 找出那一条匹配成功的路由项\n      const findMenu = menus.find((menu, index, menus) => {\n        return menu.name.includes(tmp.name)\n      })\n\n      // 赋权\n      if (findMenu.hasOwnProperty('auth')) {\n        tmp.meta = {\n          ...tmp.meta,\n          ...findMenu.auth\n        }\n      }\n\n      // 如果该路由项中含有子路由，子路由也是需要和菜单进行匹配的\n      if (findMenu.hasOwnProperty('children') && findMenu.children.length) {\n        // 子路由匹配的步骤和父路由一样\n        tmp.children = filterAsyncRoutes(tmp.children, findMenu.children)\n      } else {\n        // 将匹配不到的子路由从路由中删除\n        delete tmp.children\n      }\n\n      // 最后得到的结果就是和后台返回菜单匹配一致的异步路由值\n      res.push(tmp)\n    }\n  })\n\n  return res\n}\n\n/**\n * Use meta.role to determine if the current user has permission\n * @param menus 后台返回的菜单\n * @param route 前端定义好的异步路由中的项\n */\nfunction hasPermission(menus, route) {\n  // 进行匹配\n  if (route.name) { // 前提是异步路由要存在name\n    // 匹配的规则是，name要一致，只要匹配到就返回true，停止继续往下循环\n    return menus.some(menu => route.name.includes(menu.name))\n  } else {\n    return true\n  }\n}\n\nexport default permission\n\n```\n\n### 四、在项目中生成动态路由\n一切都准备就绪了，接下来就剩，我们应该在哪里调用生成动态路由的方法呢。我更趋向于，每次切换路由时进行判断，如果当前用户是第一次进入项目，则在路由跳转前，来调用生成动态路由的方法，路由生成之后再往下走。所以我们可以在router.beforeEach的钩子函数中调用生成动态路由的方法。\n\n在src目录下新建permission.js，用来定义router.beforeEach中的逻辑\n```javascript\nimport router from '@/router'\nimport store from '@/store'\nimport { Message } from 'element-ui'\nimport NProgress from 'nprogress' // Progress 进度条\nimport 'nprogress/nprogress.css'// Progress 进度条样式\nimport getPageTitle from '@/assets/utils/get-page-title'\n\nNProgress.configure({ showSpinner: false }) // NProgress Configuration\n\nconst whiteList = ['/login', '/register', '/resetPsw'] // 不重定向白名单\n\nrouter.beforeEach(async(to, from, next) => {\n  NProgress.start()\n\n  // set page title\n  document.title = getPageTitle(to.meta.title)\n\n  // 有无token判断\n  const token = localStorage.getItem('ADMIN_TOKEN')\n  if (token) {\n    if (whiteList.includes(to.path)) {\n      next()\n      NProgress.done()\n    } else {\n      // 判断当前用户是不是进行了刷新操作，防止进入死循环，如果存在就表示正常跳转，如果不存在就表示刷新了，vuex中的状态丢失了，需要重新挂载路由\n      const hasUser = store.state.user.token\n      if (hasUser) {\n        next()\n      } else {\n        try {\n          // 防止进入死循环\n          await store.commit('SET_TOKEN', token)\n          // 是不是超级管理员\n          const isSuperAdmin = store.state.user.roles.some(item => item.id === 1)\n          const accessRoutes = await store.dispatch('GenerateRoutes', isSuperAdmin)\n          // 异步加载路由\n          router.addRoutes(accessRoutes)\n          router.options.routes = store.state.permission.routes\n          // 设置replace：true，导航不会留下历史记录\n          next({ ...to, replace: true })\n        } catch (error) {\n          // 移除token，重定向到登录页\n          await store.dispatch('ResetToken')\n          Message.error(error || '身份验证出错，请重新登录。')\n          next(`/login?redirect=${to.path}`)\n          NProgress.done()\n        }\n      }\n    }\n  } else {\n    // 没有token\n    if (whiteList.indexOf(to.path) !== -1) {\n      next()\n    } else {\n      // next(`/login?redirect=${to.path}`) // 否则全部重定向到登录页\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done()\n    }\n  }\n})\n\nrouter.afterEach(() => {\n  NProgress.done() // 结束Progress\n})\n\n```\n\n然后在入口文件引入，全局注册：\n```javescript\n// main.js\nimport '@/permission'\n```\n\n然后运行项目，你会发现用户只能访问第一个子菜单了，是不是不难呢。\n\n### 五、根据权限来为页面加限制\n细心的大兄弟会发现我们给每个页面路由的meta下头都定义了增add、删delete、改edit、查check四个权限。我们在页面中通过```$route.meta```就能获取增删改查的具体权限哦。这里贴一个栗子，我们定义一个表格：\n```\n<template>\n  <div class=\"table-demo\">\n    <el-card class=\"list-content\" shadow=\"hover\">\n      <template v-if=\"$route.meta.check\">\n        <el-table\n          v-loading=\"tableLoading\"\n          :data=\"tableData\"\n          :cell-style=\"{ whiteSpace: 'nowrap'}\"\n          :header-row-style=\"{ background: '#EBEEF5'}\"\n          style=\"width: 100%\"\n          class=\"table-content\"\n        >\n          <el-table-column\n            type=\"index\"\n            label=\"序号\"\n            align=\"center\"\n            sortable\n            width=\"50\"\n          />\n          <el-table-column\n            v-for=\"(item,index) in tableHeader\"\n            :key=\"index\"\n            :prop=\"index\"\n            sortable\n            :label=\"item\"\n            align=\"center\"\n          />\n          <el-table-column\n            label=\"操作\"\n            width=\"230\"\n            align=\"center\"\n            class-name=\"operation\"\n          >\n            <template slot-scope=\"scope\">\n              <a v-if=\"$route.meta.edit\" class=\"item\" @click=\"test(scope.row)\">修改</a>\n              <a v-if=\"$route.meta.delete\" class=\"item\" @click=\"test(scope.row)\">删除</a>\n            </template>\n          </el-table-column>\n        </el-table>\n      </template>\n      <div v-else class=\"no-data\">\n        您暂时没有查看的权限\n      </div>\n    </el-card>\n    <!-- 分页 -->\n    <el-pagination\n      v-if=\"$route.meta.check\"\n      :total=\"total\"\n      :pager-count=\"5\"\n      :page-sizes=\"[10, 20, 30, 50]\"\n      :page-size=\"pageSize\"\n      :current-page=\"currentPage\"\n      background\n      layout=\"total, sizes, prev, pager, next, jumper\"\n      class=\"pagination\"\n      @size-change=\"handleSizeChange\"\n      @current-change=\"handleCurrentChange\"\n    />\n  </div>\n</template>\n```\n我们可以根据\n```\n$route.meta.add\n$route.meta.edit\n$route.meta.delete\n$route.meta.check\n```\n来控制相应入口的显示与否\n\n还有很多细节的东西没有详细写出来，我这里贴一下项目地址，有兴趣的可以看一看哦～\n\n- [x] [一个基于vuecli3和vue-admin-template改造的响应式后台管理系统](https://github.com/ccccai/vuecli3-ele-admin-template)\n\n效果图：\n\n\n![效果图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/26/16ccbe148faa1d63~tplv-t2oaga2asx-image.image)\n","tagIds":"4,5,6,7,10,11,12","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":99,"type":1,"groupTimestamp":"1549401764232","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/25/16cc4ae1163d42a3~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:23:44.000Z","updated_at":"2023-11-22T22:06:00.000Z","tagList":[{"id":4,"name":"CSS"},{"id":5,"name":"ECMAScript"},{"id":6,"name":"Git"},{"id":7,"name":"LESS"},{"id":10,"name":"HTML"},{"id":11,"name":"JavaScript"},{"id":12,"name":"ES6"}],"createDate":"2019-02-06"}