{"id":20,"title":"记一次图片懒加载优化","subTitle":"对项目中的图片懒加载封装方法进行优化","link":null,"description":"项目组件库中图片懒加载是根据clientTop、offsetTop、clientHeight、scrollTop之间的高度差计算结合scroll事件来实现的。最近开发的活动页面中部分页面几乎全用图片堆砌而成，在访问该页面的时候，由于频繁触发scrollTop事件，频繁进行计算，造成性能问题，导致页面卡顿，故想重构懒加载图片的封装方法，优化页面性能。","content":"## 方案一：使用getBoundingClientRect API ❌\n\n`getBoundingClientRect()`方法返回元素的宽高和其相对于视图窗口左上角的位置。如果元素的box-sizing是content-box，那么`getBoundingClientRect()`返回的宽高是元素内容宽高+padding+border的总和，如果是border-box，那么其返回的就是元素的内容宽高。\n\n\n```html\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n  }\n  .box {\n    width: 400px;\n    height: 200px;\n    margin: 100px auto;\n    border: 1px solid #ccc;\n  }\n  .child {\n    width: 200px;\n    height: 100px;\n    margin: 20px;\n    border: 1px solid #ccc;\n  }\n</style>\n<body>\n  <div class=\"box\">\n    <div class=\"child\">\n      child\n    </div>\n  </div>\n</body>\n<script>\n  const childDom = document.querySelector('.child');\n  console.log(childDom.getBoundingClientRect());\n  // --- 相对于视口左上角的位置，均是 numer ---\n  // top: 100     --- 盒子上边框距离视口顶部的距离\n  // bottom: 302  --- 盒子底边框距离视口顶部的距离 = top + height\n  // left: 394    --- 盒子左边框距离视口左侧的距离\n  // right: 796   --- 盒子右边框距离视口左侧的距离 = left + width\n  // x: 394       --- 盒子左上角相对于视口左侧的距离\n  // y: 100       --- 盒子左上角相对于视口顶部的距离\n\n  // 盒子的宽高\n  // width: 402\n  // height: 202\n</script>\n```\n\n##### 如何判断何时触发懒加载？\n\n只需要对比元素距离视口顶部的距离与视图的高度便能得知元素是否出现在了视图内：\n```js\n// clientHeight 代表当前视口的高度\nimg.getBoundingClientRect().top < document.documentElement.clientHeight;\n```\n\n但是由于我们需要动态的得知元素距离视口顶部的距离，所以如果改用这个API，仍需使用到scroll事件来监听页面的滚动，所以相对于旧的封装方法来说，计算量少了一点点，但是对于性能的消耗并没有太大的缓解，故改用这个API不是最佳选择。\n\n## 方案二：IntersectionObserver API ✅\n\n`IntersectionObserver API`可以自动\"观察\"元素是否可见，是一个能够监听元素是否到了当前视口的事件。\n\n`var io = new IntersectionObserver(callback, option);`IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。\n\n构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。\n\n```js\n// 开始观察\nio.observe(document.getElementById('example'));\n\n// 停止观察\nio.unobserve(element);\n\n// 关闭观察器\nio.disconnect();\n```\n\n##### 如何判断何时触发懒加载？\n\n直接判断，IntersectionObserverEntry对象中有 isIntersecting 属性，表示目标元素可见，故可以这样使用：\n\n```js\nconst observer = new IntersectionObserver((changes) => {\n  // changes: 目标元素集合\n  changes.forEach((change) => {\n    // intersectionRatio\n    if (change.isIntersecting) {\n      const img = change.target;\n      img.src = img.dataset.src;\n      observer.unobserve(img);\n    }\n  });\n});\n \nobserver.observe(img);\n```\n\n##### 兼容性\n\n除了IE。Chrome从49开始就已经支持该API，因为项目优先考虑Chrome兼容性，所以兼容性的问题在这个项目上来说可以忽略不计\n\n##### 注意点\n\nIntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。\n\n规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。","tagIds":"11","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":78,"type":1,"groupTimestamp":"1641671858861","cover":"https://wallpaperm.cmcm.com/90370c9b7fba347f659bdc18b2a5eae2.jpg","categoryId":1,"created_at":"2023-11-22T20:05:03.000Z","updated_at":"2023-11-23T08:53:22.000Z","tagList":[{"id":11,"name":"JavaScript"}],"createDate":"2022-01-09"}