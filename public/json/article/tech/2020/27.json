{"id":27,"title":"打造vuecli3+element后台管理系统（三）优化路由和vuex仓库，给router和store分模块","subTitle":"","link":null,"description":"我们在做后台系统的时候，经常会有比较多的功能页面，每个页面或多或少都会有需要存储在vuex中的数据，一般情况下我们会在state下定义不同的object，但是当功能一多，全部字段和action、mutations都定义在一个文件里，难免会使文件变得很难维护。全部页面的路由都定义在一个路由文件里也会使文件代码变得比较多，后期维护麻烦。所以我们应该将仓库和路由“模块化”，不同功能定义不同的模块文件，最后统一在index文件引入。","content":"### 一、路由分模块\n#### 1.1 创建router文件夹,存放路由定义文件\n- 创建modules文件夹，主要存放功能页面路由定义文件\n- 创建index.js文件，定义路由\n\n##### 1.1-1 @/router/index.js\nrouter/index.js主要功能是：\n1. 定义常规路由，即那些不需要权限就可访问的页面，比如说登录注册、后台主页、404页面等。\n2. 引入需要根据权限加载的路由模块\n3. 定义创建路由、重置路由方法\n``` javascript\n// index.js\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n// 定义常规路由\nexport const constantRoutes = [\n  {\n    path: '/redirect',\n    component: () => import('@/layout'),\n    hidden: true,\n    children: [\n      {\n        path: '/redirect/:path*',\n        component: resolve => void require(['@/views/redirect/index'], resolve)\n      }\n    ]\n  },\n  {\n    path: '/',\n    redirect: '/login'\n  },\n  {\n    path: '/login',\n    name: 'Login',\n    component: resolve => void require(['@/views/login/index'], resolve),\n    hidden: true\n  },\n  {\n    path: '/register',\n    name: 'Register',\n    component: resolve => void require(['@/views/login/register'], resolve),\n    hidden: true\n  },\n  {\n    path: '/resetPsw',\n    name: 'ResetPsw',\n    component: resolve => void require(['@/views/login/resetPsw'], resolve),\n    hidden: true\n  },\n\n  {\n    path: '/404',\n    component: () => import('@/views/404'),\n    hidden: true\n  }\n]\n\n/** 权限路由\n * 是动态的路由、需要根据权限加载的路由\n */\nconst modulesFiles = require.context('./modules', true, /\\.js$/)\nconst routesModules = []\n// 自动引入modules目录下的所有模块\nmodulesFiles.keys().reduce((modules, modulePath) => {\n  const value = modulesFiles(modulePath)\n  routesModules.push(value.default)\n}, {})\nexport const asyncRoutes = routesModules\n\n/** 404路由\n * 最终无法匹配到相应路由，重定向到404\n * 异步加载路由时，在生成完异步路由准备挂载时，需要将重定向404的匹配规则定义在最后面，否则刷新会出错。\n */\nexport const notFoundRoutes = [\n  {\n    path: '*',\n    redirect: '/404',\n    hidden: true,\n    meta: {\n      title: '404'\n    }\n  }\n]\n\n// 定义实例化路由的方法\nconst createRouter = () => new Router({\n  // mode: 'history', // require service support\n  scrollBehavior: () => ({ y: 0 }),\n  routes: constantRoutes // 挂载常规路由\n})\n// 实例化路由\nconst router = createRouter()\n\n// 定义实重置路由的方法\nexport function resetRouter() {\n  const newRouter = createRouter()\n  router.matcher = newRouter.matcher // reset router\n}\n\nexport default router\n```\n\n### 二、vuex仓库分模块\n和router模块一样，咱也需要给store模块创建一个文件夹，在里头存放定义文件\n#### 2.1 创建store文件夹,存放vuex定义文件\n- 创建modules文件夹，主要存放各模块下的仓库定义文件\n- 创建index.js文件，初始化vuex实例\n- 使用vuex持久化插件vuex-persistedstate，让你的数据可以实现刷新也不丢失噢~\n\n##### 2.1-1 @/store/index.js\n该文件声明了vuex实例，同时批量引入modules下的store文件，也声明了vuex-persistedstate插件实例。\n\n```!\n关于persistedState的初始化，注意vuex中的参数不是全部都要持久化，你可以根据业务逻辑自行定义需要持久化的参数\n```\n\n``` javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\nimport createPersistedState from 'vuex-persistedstate'\n\nVue.use(Vuex)\n\n// （创建了）一个包含了modules文件夹（包含子目录）下面的，所有文件名以 `.js` 结尾的、能被 require 请求到的文件的上下文。\nconst modulesFiles = require.context('./modules', true, /\\.js$/)\n// keys() 方法用于从modules创建一个包含modules里键值的可迭代对象。\nconst modules = modulesFiles.keys().reduce((modules, modulePath) => {\n  // 模块名，取文件名\n  const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1')\n  // 获取键名为modulePath的文件内容\n  const value = modulesFiles(modulePath)\n  // 将文件中的默认导出模块 赋值给迭代对象modules\n  modules[moduleName] = value.default\n  // 返回迭代对象modules\n  return modules\n  // 默认值是空对象{}\n}, {})\n\n// 创建仓库实例\nconst store = new Vuex.Store({\n  modules,\n  getters,\n  // 使用持久化插件\n  plugins: [\n    // 存储vuex状态，使之刷新不丢失\n    createPersistedState({\n      // 这里我用的是localStorage，你也可以改成sessionStorage，cookie也行不过我没研究嘻嘻嘻\n      storage: window.localStorage,\n      reducer(val) {\n        return {\n          // 将要存储的state中的值放在这里\n          user: {\n            name: val.user.name\n          }\n        }\n      }\n    })\n  ]\n})\n\nexport default store\n\n```\n\n那我们就来看看咋使用，我们可以写个userjs来试试，里头定义登录登出的action，因为登录登出可能不止一个地方会运用到，而且登录登出可能会涉及到state里头好几个状态值的改变，所以我就把登录登出的逻辑写在action里头，这样分发的时候也可以改变状态值：\n##### 2.1-2 modules目录下新建user.js，用来存放用户信息，定义登陆、登出的action\n``` javascript\nimport API from '@/assets/http/apiUrl'\nimport Request from '@/assets/http'\n\nconst user = {\n  state: {\n    token: '',\n    name: ''\n  },\n  mutations: {\n    SET_TOKEN: (state, data) => {\n      // 先初步定义token和username这两个值\n      state.token = data\n      localStorage.setItem('ADMIN_TOKEN', data)\n    },\n    SET_NAME: (state, data) => {\n      state.name = data\n    }\n  },\n  actions: {\n    // 登陆\n    Login({ commit }, params) {\n      return new Promise((resolve, reject) => {\n        Request.httpRequest({\n          method: 'post',\n          url: API.Login,\n          params: params,\n          success: data => {\n            commit('SET_TOKEN', data.token)\n            resolve(data)\n          },\n          error: err => {\n            reject(err)\n          }\n        })\n      })\n    },\n\n    // 短信登录，这里为了方便我就直接复用登录的action了，正式项目中肯定要调用另外的接口\n    LoginByVin({ dispatch, commit }, params) {\n      return dispatch('Login', params)\n    },\n\n    // 重置token和state值\n    ResetToken({ commit }) {\n      return new Promise(resolve => {\n        commit('SET_TOKEN', '')\n        commit('SEI_NAME', '')\n        localStorage.removeItem('ADMIN_TOKEN')\n        resolve()\n      })\n    },\n\n    // 登出\n    LogOut({ dispatch, commit }) {\n      return dispatch('ResetToken')\n    }\n  }\n}\n\nexport default user\n\n```\n新建之后不需要在index那里引入哦，因为我们已经写了批量引入的逻辑啦～是不是很方便呢\n\n然后就是使用了，关于Login，在登陆页面只需要分发action就行：\n```\nparams = {\n    'username': this.loginForm.user,\n    'password': this.loginForm.password\n}\nthis.$store.dispatch('Login', params).then(() => {\n    this.loading = false\n    this.$router.push({ path: this.redirect || '/home' })\n}).catch(() => {\n    this.loading = false\n})\n```\n\n具体代码逻辑可以下载项目来看一下下\n- [x] [一个基于vuecli3和vue-admin-template改造的响应式后台管理系统](https://github.com/ccccai/vuecli3-ele-admin-template/tree/withoutAuth)","tagIds":"4,5,7,10,11,12,37","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":99,"type":1,"groupTimestamp":"1580246634809","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/25/16cc4ae1163d42a3~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:24:53.000Z","updated_at":"2023-11-24T05:44:56.000Z","tagList":[{"id":4,"name":"CSS"},{"id":5,"name":"ECMAScript"},{"id":7,"name":"LESS"},{"id":10,"name":"HTML"},{"id":11,"name":"JavaScript"},{"id":12,"name":"ES6"},{"id":37,"name":"Vue"}],"createDate":"2020-01-29"}