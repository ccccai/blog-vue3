{"id":28,"title":"打造vuecli3+element后台管理系统（二）调用接口功能完善，定义axios工具类","subTitle":"一个基于vuecli3和vue-admin-template改造的响应式后台管理系统","link":null,"description":"后台系统少不了登陆、注册、重置密码功能。虽说是三个页面，但是样式风格统一，所以只用写一套样式。这块内容不多，咱来好好梳理，写一写。","content":"[一个基于vuecli3和vue-admin-template改造的响应式后台管理系统](https://github.com/ccccai/vuecli3-ele-admin-template)\n\n先上效果图\n\n![登陆、注册、重置密码](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/17/16c9dd7205f6143f~tplv-t2oaga2asx-image.image)\n\n### 一、使用mockjs\n运用mock来模拟后台接口能更加便捷高效的进行前端开发，在这里我只是简单的模拟后台接口，返回一些简单的数据，更多功能可以参考[mockjs官网](http://mockjs.com/)，写的很详细的噢～\n\n#### 1.1 引入mockjs\n``` bash\nnpm install --save-dev mockjs\n```\n\n#### 1.2 在mainjs引入\n``` javascript\nimport '@/assets/mock'\n```\n\n#### 1.3 定义mock文件\n在assets文件夹下创建mock文件夹，并创建index.js\n``` javascript\nimport Mock from 'mockjs'\n// 获取 mock.Random 对象\nconst Random = Mock.Random\n\n// mock一组数据\nconst loginData = () => {\n  const data = {\n    token: Random.string(10)\n  }\n  return {\n    data: data,\n    resultCode: 1,\n    resultMessage: 'success'\n  }\n}\nMock.mock('/apiReplace/login', 'post', loginData)\nMock.mock('/apiReplace/loginByVin', 'post', loginData)\n```\n\n### 二、Api地址的统一定义和处理\n在assets目录下新建http文件夹，用来存放请求后端接口的一些配置文件。\n> 后台的接口地址需要一个文件进行统一的定义，然后全局声明之后，可以在项目里任意使用\n\n#### 2.1 定义接口url\n根目录新建http/apiUrl.js，定义接口url\n``` javascript\n/* 全局定义接口url */\n\n// 接口前缀\nconst prefix = '/api/'\n// host头，字符串apiReplace是代理时本地开发的标记字符串。\nconst apiHost = process.env。NODE_ENV === 'dev' ? `/apiReplace${prefix}` : prefix\n\nexport default {\n// 密码登录\n    Login: `${apiHost}login`,\n    // 短信登录\n    LoginByVin: `${apiHost}loginByVin`\n}\n```\n\n#### 2.2 在mainjs引入\n\n``` javascript\nimport Api from '@/assets/http/apiUrl'\nVue.prototype.API = Api\n```\n这样我们就能在项目里通过this.API.xxx去获取相应的接口url了\n\n### 三、axios工具类的封装\n> 总所周知，使用axios调用后台接口时，每次都需要写这么长串：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/17/16c9ff76eaa593a8~tplv-t2oaga2asx-image.image)\n\n当业务逻辑复杂的时候，写起来会比较繁琐，后期维护更加不方便，每次都要定位到具体位置去一个个替换修改。所以在axios请求时再封装一层就显得尤为重要。\n\n#### 3.1 axios拦截器\n> 我们经常需要在发起请求之前，修改请求头或者是在接口请求成功之后进行数据的预处理，axios给我们提供了request和response的拦截器，让我们可以在这里头进行一些业务操作。\n\n直接执行`vue add axios`添加axios插件，执行成功之后会自动生成plugins目录，并在该目录下生成axios.js文件，我们需要在这个基础上修改。\n\n修改plugins/axios.js文件\n\n- 在文件头引入需要的模块并创建axios实例\n``` javascript\n'use strict'\n\nimport Vue from 'vue'\nimport axios from 'axios'\nimport { getToken } from '@/assets/utils/token'\nimport router from '@/router'\nimport store from '@/store'\nimport defaultSettings from '@/settings'\nimport {\n  Message,\n  Loading\n} from 'element-ui'\nimport Qs from 'qs'\n\nconst config = {\n  baseURL: process.env。NODE_ENV === 'dev' ? `http://localhost:${defaultSettings.devPort}` : `${defaultSettings.prodHost}`, // api的base_url\n  timeout: 60 * 1000 // 请求超时时间\n  // withCredentials: true, // Check cross-site Access-Control\n}\n```\n\n- request拦截器，设置请求头参数，如用户标识token等\n``` javascript\n// request拦截器\nservice.interceptors.request.use(\n  config => {\n    // 在此处设置请求头参数\n    const token = getToken()\n    if (token != null) {\n      config.headers['Authorization'] = token\n    }\n    return config\n  },\n  error => {\n    // Do something with request error\n    console.log(error) // for debug\n    return Promise.reject(error)\n  }\n)\n```\n\n- response 拦截器，请求接口得到相应后，需要进行一些预处理\n``` javascript\nservice.interceptors.response.use(\n  response => {\n    return response // 返回请求成功结果，status=200\n  },\n  err => {\n    // 请求失败时，即status!=200\n    if (err && err.response) {\n      switch (err.response.status) {\n        case 400:\n          err.message = '错误请求'\n          break\n        case 401:\n          err.message = '未授权，请重新登录'\n          break\n        case 403:\n          err.message = '禁止访问'\n          break\n        case 404:\n          err.message = '请求错误,未找到该资源'\n          break\n        case 405:\n          err.message = '请求方法未允许'\n          break\n        case 408:\n          err.message = '请求超时'\n          break\n        case 413:\n          err.message = '上传文件过大'\n          break\n        case 500:\n          err.message = '服务器端出错'\n          break\n        case 501:\n          err.message = '网络未实现'\n          break\n        case 502:\n          err.message = '网络错误'\n          break\n        case 503:\n          err.message = '服务不可用'\n          break\n        case 504:\n          err.message = '网络超时'\n          break\n        case 505:\n          err.message = 'http版本不支持该请求'\n          break\n        default:\n          err.message = `连接错误,${err.response.msg}`\n      }\n    } else {\n      err.message = '当前网络状态不佳'\n    }\n    Message.closeAll()\n    Message({\n      message: err.message || '数据解析出错',\n      type: 'error',\n      customClass: 'errorloginwidth',\n      duration: '3000'\n    })\n    // 如果是token过期的状况，退出登陆重定向到登陆页\n    if (err.response && err.response.status === 401) {\n      store.dispatch('FedLogOut') // 前端登出，移除token\n      router.replace({\n        path: `/login?redirect=${window.location.href.split(/[#]/g)[1]}`\n      })\n    }\n    return Promise.reject(err)\n  }\n)\n```\n\n- 导出模块\n``` javascript\nexport default service\n```\n\n#### 3.2 axios请求封装\n##### 3.2-1 引入Qs库来格式化数据\n``` bash\nnpm install --save-dev qs\n```\n\n##### 3.2-2 分别处理get和post请求，get和post请求携带参数的方式是不同的，所以要分开定义\n\n##### 3.2-3 提供请求成功和失败后的回调函数，以便页面里进行相关逻辑的书写\n直接贴上我定义的文件：\n\n这里我只定义了一个基本的httpRequest方法，后期如果需要定义并发调用、或者其他情景下的方法，都可以自行增加。\n\n``` javascript\n/* 封装axios请求 */\n/* 用法示例：(*)为必须参数\n  this.$request.httpRequest({\n    headers: false, // 是否格式化参数\n    (*)method: 'post', // 请求方式，post或get\n    (*)url: this.API.ResetPassword, // 请求地址，请求地址的配置在@/api/apiUrl.js\n    noLoading: true, // 是否显示全局Loading遮罩，默认每个请求都显示遮罩，即默认不设置该参数。如果需要某个请求不加遮罩，就设置noLoading: true即可\n    returnFullData: true, // 是否返回完整数据，例如接口返回的数据格式为{ code:0, data: [], meaasge:''}，则默认请求成功之后的回调函数的参数为data:[]，如果设置returnFullData: true，则回调参数为{ code:0, data: [], meaasge:''}\n    hideErrorMsg: true, // 是否展示错误提示\n    (*)params: {}, // 请求参数，object类型\n    (*)success: (data) => { // 请求成功之后的回调函数，data是回调参数\n      // 在这里写请求成功后的逻辑\n    },\n    error: (err) => { 请求不成功之后的回调函数，data是回调参数\n      // 在这里写请求报错后的逻辑\n    }\n  })\n*/\nimport service from './service'\nimport { Message, Loading } from 'element-ui'\nimport Qs from 'qs'\n\nfunction requestMethods(options) {\n  return new Promise((resolve, reject) => {\n    try {\n      switch (options.method) {\n        case 'post':\n          if (options.headers) {\n            resolve(\n              service({\n                url: options.url,\n                method: 'post',\n                data: options.params\n              })\n            )\n          } else {\n            resolve(\n              service({\n                url: options.url,\n                method: 'post',\n                data: Qs.stringify(options.params)\n              })\n            )\n          }\n          break\n        case 'get':\n          resolve(\n            service({\n              url: options.url,\n              method: 'get',\n              params: options.params\n            })\n          )\n          break\n        default: // 默认是get调用\n          resolve(\n            service({\n              url: options.url,\n              method: 'get',\n              params: options.params\n            })\n          )\n          break\n      }\n    } catch (e) {\n      Message({\n        message: 'HTTP请求方法出错！',\n        type: 'error',\n        duration: 3 * 1000\n      })\n      reject('methods error!')\n    }\n  })\n}\n\nfunction httpRequest(options = {}) {\n  let loading\n  if (!options.noLoading) {\n    // 启用全局loading\n    loading = Loading.service({\n      lock: true,\n      text: '加载中...',\n      spinner: 'el-icon-loading',\n      background: 'rgba(0, 0, 0, 0.7)'\n    })\n  }\n\n  requestMethods(options).then(response => {\n    // 成功返回结果的逻辑。根据接口定义的数据返回格式 修改判断条件\n    const data = response.data\n    if (data.resultCode === '1' || data.resultCode === 1) {\n      // 成功\n      const result = options.returnFullData ? data : data.data // 返回完整数据结构还是只返回有效数据\n      options.success(result)\n    } else {\n      if (!options.hideErrorMsg) {\n        // 失败\n        let errorMsg = data.hasOwnProperty('resultMessage') ? data.resultMessage : '数据解析错误'\n        switch (data.resultCode) {\n          case '401':\n            errorMsg = '暂无操作权限'\n            break\n        }\n        Message.closeAll()\n        Message({\n          message: errorMsg,\n          type: 'error',\n          customClass: 'errorloginwidth',\n          duration: 3000\n        })\n      }\n      options.error(data)\n    }\n    if (!options.noLoading) {\n      // loading完毕\n      loading.close()\n    }\n  }).catch(e => {\n    options.error(e.response)\n  })\n}\nexport default {\n  httpRequest\n}\n```\n\n#### 3.3 在mainjs引入\n\n``` javascript\nimport Request from '@/assets/http'\nVue.prototype.$request = Request\n```\n\n这样就可以在项目中通过this.$request去调用接口啦～\n基础调用很简单，只用酱紫：\n\n``` bash\n this.$request.httpRequest({\n    url: this.API.SendSms,\n    params: {},\n    success: (data) => {\n        // 在这里写成功调用接口后的逻辑\n    }\n  })\n```\n\n那复杂的用法这里贴个例子，完整代码可以去看看项目代码哦，地址我会贴在文章头。\n\n比如说这个登陆页面，要获取手机验证码：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/18/16ca4645a2e3801a~tplv-t2oaga2asx-image.image)\n\n点击发送验证码，开始一分钟倒计时并调用发送短信验证码的接口\n\n```html\n<!--html部分-->\n<el-form-item prop=\"code\" class=\"login-input-item\">\n    <span class=\"svg-container\">\n        <svg-icon icon-class=\"password\" />\n    </span>\n    <el-input\n        v-model=\"loginForm.code\"\n        autocomplete=\"off\"\n        type=\"number\"\n        name=\"code\"\n        placeholder=\"验证码\"\n        maxlength=\"4\"\n        style=\"padding-left: 45px\"\n        @keyup.enter.native=\"handleLogin\"\n    />\n    <span\n        :style=\"{ cursor: isOvertime ? 'default' : 'pointer'}\"\n        class=\"code\"\n        @click=\"sendMessage\">\n            {{ word }}\n    </span>\n</el-form-item>\n\n// js部分\nsendMessage() {\n  if (this.isOvertime) {\n    return false // 还在倒计时，不往下执行\n  }\n  const params = {\n    'phone': this.loginForm.phoneNumber\n  }\n  if (!params.phone) {\n    this.$message.closeAll()\n    this.$message.error('请先输入手机号码')\n    return\n  }\n  if (!isvalidPhoneNumber(params.phone)) {\n    this.$message.closeAll()\n    this.$message.error('手机号格式不正确')\n    return\n  }\n  this.loading = true\n  this.$request.httpRequest({\n    method: 'post',\n    url: this.API.SendSms,\n    returnFullData: true,\n    noLoading: true,\n    hideErrorMsg: true,\n    params: params,\n    success: (data) => {\n      this.loading = false\n      this.$message.closeAll()\n      this.$message.success('验证码发送成功，请留意手机短信')\n      const sendTimer = setInterval(() => {\n        this.isOvertime = true\n        this.word = `${this.time}s后重新获取`\n        this.time--\n        if (this.time <= 0) {\n          this.isOvertime = false\n          this.time = 60\n          clearInterval(sendTimer)\n          this.word = '获取验证码'\n        }\n      }, 1000)\n    },\n    error: (e) => {\n      this.loading = false\n      const errorMsg = e.hasOwnProperty('resultMessage') ? e.resultMessage : '获取验证码失败'\n      this.$message({\n        message: errorMsg,\n        type: 'error',\n        customClass: 'errorloginwidth',\n        duration: 3000\n      })\n    }\n  })\n}\n\n```\n\n","tagIds":"4,5,7,10,11,12,37","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":99,"type":1,"groupTimestamp":"1579728299521","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/25/16cc4ae1163d42a3~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:26:13.000Z","updated_at":"2023-11-24T18:34:50.000Z","tagList":[{"id":4,"name":"CSS"},{"id":5,"name":"ECMAScript"},{"id":7,"name":"LESS"},{"id":10,"name":"HTML"},{"id":11,"name":"JavaScript"},{"id":12,"name":"ES6"},{"id":37,"name":"Vue"}],"createDate":"2020-01-23"}