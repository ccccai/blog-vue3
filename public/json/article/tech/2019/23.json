{"id":23,"title":"我的第一个node项目，用koa+sequelize来开发接口","subTitle":"","link":null,"description":"一直都很想尝试用node来写点东西，学习了一番之后依葫芦画瓢用koa框架加上sequelize ORM从零开始用MVC模式编写了个简单的后台项目，故在此做一下记录。","content":"### 一、构建项目\n\n#### 1、创建文件夹，初始化项目\n\n```bash\nmkdir node-koa-demo # 创建项目\ncd node-koa-demo # 进入目录\ncnpm init -y # 生成package.json\ncnpm install koa koa-body koa-router koa-static koa2-cors path -S # 安装koa插件\ntouch app.js # 生成入口文件\n```\n\n\n\n#### 2、定义项目启动命令\n\n```json\n// package.json\n{\n  \"name\": \"node-koa-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"node app.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"koa\": \"^2.11.0\",\n    \"koa-body\": \"^4.1.1\",\n    \"koa-router\": \"^7.4.0\",\n    \"koa-static\": \"^5.0.0\",\n    \"koa2-cors\": \"^2.0.6\",\n    \"path\": \"^0.12.7\"\n  }\n}\n\n```\n\n#### 3、定义入口文件\n\n```javascript\n// app.js\nconst Koa = require('koa')\nconst app = new Koa()\nconst config = require('./config')\nconst path = require('path')\nconst koaBody = require('koa-body')({ // // 解析body的中间件\n  multipart: true, // 支持文件上传\n  encoding:'gzip',\n  formLimit: '5mb', // 限制表单请求体的大小\n  jsonLimit: '5mb', // JSON 数据体的大小限制\n  textLimit: '5mb', // 限制 text body 的大小\n  formidable:{\n    uploadDir: path.join(__dirname, '/public/upload'), // 设置文件上传目录\n    keepExtensions: true,    // 保持文件的后缀\n    maxFieldsSize: 200 * 1024 * 1024, // 设置上传文件大小最大限制，默认2M\n    onFileBegin: (name, file) => { // 文件上传前的设置\n      console.log(`name: ${name}`)\n      console.log(file)\n    }\n  }\n})\nconst static = require('koa-static')\n\n// 解析body的中间件\napp.use(koaBody)\napp.use(static(path.join(__dirname)))\n\napp.listen(config.service.port, () => {\n  console.log('server is running')\n})\n\n```\n\n#### 4、定义配置文件\n\n##### 1）定义本地配置文件env文件：\n.env文件：\n```javascript\n// .env\nSERVE_PORT=[项目端口]\nSERVE_ENVIROMENT=[项目所处环境]\n```\n\n安装dotenv插件用来在项目中引用env文件\n\n```bash\ncnpm install dotenv -S # 用来引入.env配置环境变量\n```\n\n入口文件引入插件：\n\n```javascript\nconst dotenv = require('dotenv') // 引入配置文件\ndotenv.config()\n```\n\n##### 2）定义项目中的配置文件config.js：\n\nconfig.js：\n```javascript\nmodule.exports = {\n  service: {\n    port: process.env['SERVE_PORT'],\n    enviroment: process.env['SERVE_ENVIROMENT'] || 'dev'\n  }\n}\n```\n\n入口文件引入config.js：\n\n```javascript\nconst config = require('./utils/config')\nglobal.config = config\n```\n\n> 启动项目： ```cnpm run start ```\n\n#### 5、项目热更新\n安装插件\n```bash\ncnpm install nodemon -S\n```\n\n##### 添加命令：\n\n```json\n// package.json\n\"start:dev\": \"nodemon node app.js\"\n```\n\n### 二、开发接口\n\n#### 1、sequelize连接mysql\n\n##### 1）安装相关依赖\n\n```bash\ncnpm install mysql2 sequelize -S\n```\n\n##### 2）创建数据库配置文件夹db\n\n```bash\nmkdir db\ntouch db/index.js\n```\n\n##### 3）定义数据库连接配置，并引入\n\n```javascript\n// .env\nDB_DATABASE=[数据库名称]\nDB_USER=[数据库用户名]\nDB_PSW=[数据库连接密码]\nDB_HOST=[数据库端口]\n```\n\n##### 4）定义sequelize文件\n```javascript\n\n// db/index.js\nconst Sequelize = require('sequelize')\n\nconst sequelize = new Sequelize(\n  process.env['DB_DATABASE'],\n  process.env['DB_USER'],\n  process.env['DB_PSW'], \n  {\n    host: process.env['DB_HOST'], // 数据库地址\n    dialect: 'mysql', // 数据库类型\n    dialectOptions: { // 字符集\n      charset:'utf8mb4',\n      collate:'utf8mb4_unicode_ci',\n      supportBigNumbers: true,\n      bigNumberStrings: true\n    },\n    pool: {\n      max: 5, // 连接池最大链接数量\n      min: 0, // 最小连接数量\n      idle: 10000 // 如果一个线程10秒内没有被使用的花，就释放连接池\n    },\n    timezone: '+08:00', // 东八时区\n    logging: (log) => {\n      console.log('dbLog: ', log)\n      return false\n    } // 执行过程会打印一些sql的log，设为false就不会显示\n  }\n)\n\nmodule.exports = sequelize\n```\n\n##### 5）定义model\n\n```bash\nmkdir model\ntouch model/User.js\n```\n\n```javascript\nconst Sequelize = require('sequelize')\nconst sequelize = require('../db')\n\nconst User = sequelize.define('user', {\n  id: {\n    type: Sequelize.INTEGER,\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    comment: 'ID', // 字段描述（自1.7+后，此描述不再添加到数据库中\n    autoIncrement: true, // 是否自增\n    primaryKey: true, // 指定是否是主键\n    unique: true, // 设置为true时，会为列添加唯一约束\n  },\n  password: {\n    type: Sequelize.STRING(20),\n    validate: {}, // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    comment: '密码' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n  name: {\n    type: Sequelize.STRING(20),\n    validate: {\n      notEmpty: true\n    }, // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    comment: '用户名称' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n  email: {\n    type: Sequelize.STRING(20),\n    validate: {\n      isEmail: true\n    }, // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    comment: 'email' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n  phone: {\n    type: Sequelize.STRING(11),\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    comment: '手机号码' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n  birth: {\n    type: Sequelize.DATE,\n    validate: {\n      isDate: true\n    }, // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    defaultValue: new Date(), // 字面默认值, JavaScript函数, 或一个 SQL 函数\n    comment: '生日' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n  sex: {\n    type: Sequelize.INTEGER,\n    validate: {\n      isInt: true,\n      len: 1\n    }, // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数\n    allowNull: false, // 设置为false时，会给添加NOT NULL（非空）约束，数据保存时会进行非空验证\n    defaultValue: 0, // 字面默认值, JavaScript函数, 或一个 SQL 函数\n    comment: '性别，0-男 1-女' // 字段描述（自1.7+后，此描述不再添加到数据库中）\n  },\n}, {\n  freezeTableName: true, // 设置为true时，sequelize不会改变表名，否则可能会按其规则有所调整\n  timestamps: true, // 为模型添加 createdAt 和 updatedAt 两个时间戳字段\n})\n\n//创建表，默认是false，true则是删除原有表，再创建\nUser.sync({\n  force: false,\n})\n\nmodule.exports = User\n```\n\n###### [*自动暴露model（根据需要自行选择是否需要自动暴露所有model）]\n\n```javascript\n// model/index.js\n\n/* 扫描所有的model模型 */\nconst fs = require('fs')\nconst files = fs.readFileSync(__dirname + '/model') // 遍历目录\nconst jsFiles = files.filter(item => {\n  return item.endsWith('.js')\n}, files)\n\nmodule.exports = {}\nfor (const file of jsFiles) {\n  console.log(`import model from file ${file}`)\n  const name = file.substring(0, file.length - 3)\n  module.exports[name] = require(__dirname + '/model/' + file)\n}\n```\n\n#### 2、定义路由\n\n```bash\nmkdir router\ntouch router/index.js\n```\n\n```javascript\n// router/index.js\nconst router = require('koa-router')({\n  prefix: '/api'\n})\n\nrouter.get('/', async(ctx, next) => {\n  ctx.body = 'Hello World~'\n})\n\nmodule.exports = router\n```\n\n在入口文件app.js引入\n\n```javascript\n// 路由中间件\nconst router = require('./router')\n// 开始服务并生成路由\napp.use(router.routes()).use(router.allowedMethods()) // 开始服务并生成路由\n```\n\n\n#### 3、自定义中间件\n\n##### 1）创建中间件文件夹\n\n```bash\nmkdir middleware\n```\n\n##### 2）定义一个错误处理中间件\n\n```bash\ntouch middleware/exception.js # 中间件文件\ntouch utils/http-exception.js # 定义已知异常类\n```\n\n##### 3）定义已知异常类继承于Error类\n明确已知异常还是未知异常\n\n```javascript\n// utils/http-exception.js\n/**\n * 默认的异常\n */\nclass HttpException extends Error {\n  constructor(msg = '错误请求', errorCode = 10000, code = 400) {\n    super()\n    this.errorCode = errorCode\n    this.code = code\n    this.msg = msg\n  }\n}\n\nclass ParameterException extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 400\n    this.msg = msg || '参数错误'\n    this.errorCode = errorCode || 10000\n  }\n}\n\nclass AuthFailed extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 401\n    this.mag = msg || '授权失败'\n    this.errorCode = errorCode || 10004\n  }\n}\n\nclass NotFound extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 404\n    this.msg = msg || '未找到该资源'\n    this.errorCode = errorCode || 10005\n  }\n}\n\nclass Forbidden extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 403\n    this.msg = msg || '禁止访问'\n    this.errorCode = errorCode || 10006\n  }\n}\n\nclass Oversize extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 413\n    this.msg = msg || '上传文件过大'\n    this.errorCode = errorCode || 10007\n  }\n}\n\nclass InternalServerError extends HttpException {\n  constructor(msg, errorCode) {\n    super()\n    this.code = 500\n    this.msg = msg || '服务器出错'\n    this.errorCode = errorCode || 10008\n  }\n}\n\nmodule.exports = {\n  HttpException,\n  ParameterException,\n  AuthFailed,\n  NotFound,\n  Forbidden,\n  Oversize,\n  InternalServerError\n}\n```\n\n##### 4）定义异常处理中间件\n\n```javascript\n// middleware/exception.js\nconst { HttpException } = require('../utils/http-exception')\n\n// 全局异常监听\nconst catchError = async(ctx, next) => {\n  try {\n    await next()\n  } catch(error) {\n    // 已知异常\n    const isHttpException = error instanceof HttpException\n    // 开发环境\n    const isDev = global.config.service.enviroment === 'dev'\n\n    // 在控制台显示未知异常信息：开发环境下，不是HttpException 抛出异常\n    if (isDev && !isHttpException) {\n      throw error\n    }\n\n    /**\n     * 是已知错误，还是未知错误\n     * 返回：\n     *      msg 错误信息\n     *      error_code 错误码\n     */\n    if (isHttpException) {\n      ctx.body = {\n        msg: error.msg,\n        error_code: error.errorCode\n      }\n      ctx.response.status = error.code\n    } else {\n      ctx.body = {\n        msg: '未知错误',\n        error_code: 9999\n      }\n      ctx.response.status = 500\n    }\n  }\n}\n\nmodule.exports = catchError\n```\n\n##### 5）入口文件加载引入异常处理中间件\n\n```javascript\n// 加载全局异常\nconst errors = require('./utils/http-exception')\nglobal.errs = errors\n\nconst app = new Koa()\n// 全局异常中间件监听、处理，放在所有中间件的最前面\nconst catchError = require('./middleware/exception')\napp.use(catchError)\n```\n\n#### 4、定义API统一返回格式\n\n##### 1）resJson.js定义接口返回格式\n\n```javascript\n// utils/resJson.js\nconst ResultJson =  {\n  success: (params) => {\n    return {\n      data: params.data || null, // 返回的数据\n      msg: params.msg || '操作成功', // 返回的提示信息\n      code: 1 // 返回的接口调用状态码，0-失败，1-成功\n    }\n  },\n  fail: (params) => {\n    return {\n      data: params.data || null,\n      msg: params.msg || '操作失败',\n      code: 0,\n      error_code: params.errorCode // 返回接口异常信息码\n    }\n  }\n}\n\nmodule.exports = ResultJson\n```\n##### 2）在中间件中使用\n\n修改上文提到的异常处理中间件\n\n```javascript\n/* 错误处理中间件 */\nconst { HttpException } = require('../utils/http-exception')\nconst resJson = require('../utils/resJson')\n\n// ...省略上文\n    if (isHttpException) {\n      ctx.body = resJson.fail(error)\n      ctx.response.status = error.code\n    } else {\n      ctx.body = resJson.fail({\n        msg: '未知错误',\n        error_code: 9999\n      })\n      ctx.response.status = 500\n    }\n// ...省略下文\n\n```\n\n#### 5、[小试牛刀] 编写一个返回所有用户信息的接口\n\n##### 1）创建控制器文件夹，定义User.js，用来对User表进行的操作。\n\n```bash\nmkdir controller\ntouch controller/User.js\n```\n\n###### 2）获取全部用户列表\n\n```javascript\nconst User = require('../model/User.js')\nconst resJson = require('../utils/resJson')\n\nmodule.exports = {\n  selectAll: async (ctx, next) => {\n    await User.findAll({\n      raw: true,\n      attributes: { // 不返回password字段\n        exclude: ['password'] \n      }\n    }).then((res) => {\n    \t// 成功返回\n      ctx.body = resJson.success({data: res})\n    }).catch((err) => {\n    \t// 失败，捕获异常并输出\n      ctx.body = resJson.fail(err)\n    })\n  }\n}\n\n```\n\n##### 3）声明接口路径\n\n```javascript\n// router/index.js\nconst router = require('koa-router')({\n  prefix: '/api'\n})\n// User控制器\nconst User = require('../controller/user')\n\n// 获取全部用户\nrouter.get('/user/list', User.selectAll)\n\nmodule.exports = router\n```\n\n##### 4）访问接口\n访问接口地址：http://localhost:3002/api/user/list\n\n访问结果：\n```json\n{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"cai\",\n            \"email\": \"cai@qq.com\",\n            \"phone\": \"13234323453\",\n            \"birth\": \"2019-12-13T01:23:17.000Z\",\n            \"sex\": 1,\n            \"createdAt\": \"2019-12-13T01:23:42.000Z\",\n            \"updatedAt\": \"2019-12-13T01:23:42.000Z\"\n        }\n    ],\n    \"msg\": \"操作成功\",\n    \"code\": 1\n}\n```","tagIds":"12,11,13,17,19","author":"菜头","authorAvatar":"http://3.bp.blogspot.com/-powJHBZ_dI0/Uuax5aG2dQI/AAAAAAAAHjY/BrKvCsBzaCU/s1600/minions-gifs-animados-imagens-que-se-mexem.gif","weight":55,"type":1,"groupTimestamp":"1550610995346","cover":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/20/170620b0b56cf87b~tplv-t2oaga2asx-jj:216:144:0:0:q75.avis","categoryId":1,"created_at":"2023-11-22T21:17:53.000Z","updated_at":"2023-11-22T21:45:18.000Z","tagList":[{"id":11,"name":"JavaScript"},{"id":12,"name":"ES6"},{"id":13,"name":"NodeJS"},{"id":17,"name":"Koa"},{"id":19,"name":"Mysql"}],"createDate":"2019-02-20"}